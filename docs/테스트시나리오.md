# DHCP 성능 테스트 시나리오 및 벤치마크 가이드

## 📋 목차
1. [테스트 시나리오 개요](#1-테스트-시나리오-개요)
2. [기본 성능 테스트](#2-기본-성능-테스트)
3. [실제 환경 시뮬레이션](#3-실제-환경-시뮬레이션)
4. [스트레스 테스트](#4-스트레스-테스트)
5. [네트워크 장애 시나리오](#5-네트워크-장애-시나리오)
6. [벤치마크 기준](#6-벤치마크-기준)
7. [성능 분석 및 리포팅](#7-성능-분석-및-리포팅)

## 1. 테스트 시나리오 개요

### 1.1 테스트 분류

#### 기능 테스트
- **기본 DHCP 기능**: 4-way handshake 검증
- **Relay Agent 기능**: Option 82 처리 검증
- **재시도 로직**: RFC 2131 준수 확인
- **IP 풀 관리**: 할당/해제/갱신 검증

#### 성능 테스트
- **처리량 테스트**: 초당 요청 처리 수 (RPS)
- **응답 시간 테스트**: 평균/최대/백분위수 응답 시간
- **동시성 테스트**: 동시 클라이언트 수 한계점
- **확장성 테스트**: 리소스 사용량 대비 성능

#### 안정성 테스트
- **장시간 실행**: 메모리 누수 및 안정성 검증
- **장애 복구**: 네트워크 장애 시 복구 능력
- **리소스 고갈**: IP 풀 고갈 상황 처리
- **에러 처리**: 비정상 패킷 처리 능력

### 1.2 테스트 환경 구성

#### 로컬 테스트 환경
```bash
# 최소 테스트 환경
./dhcp-server -start-ip 192.168.100.10 -end-ip 192.168.100.50 &
./dhcp-tester -server 127.0.0.1 -clients 50 -concurrency 10

# 중간 테스트 환경  
./dhcp-server -start-ip 10.0.1.10 -end-ip 10.0.1.250 -max-concurrent 1000 &
./dhcp-tester -server 127.0.0.1 -clients 500 -concurrency 50

# 고부하 테스트 환경
./dhcp-server -start-ip 172.16.0.10 -end-ip 172.16.10.250 -max-concurrent 5000 &
./dhcp-tester -server 127.0.0.1 -clients 5000 -concurrency 200
```

#### 분산 테스트 환경
```bash
# 서버 (고성능 머신)
./dhcp-server -listen 0.0.0.0 -start-ip 10.0.0.10 -end-ip 10.0.50.250 \
  -max-concurrent 10000 -live

# 클라이언트 1 (첫 번째 테스트 머신)
./dhcp-tester -server 10.0.0.1 -clients 10000 -concurrency 500 \
  -circuit-id "test-client-1" -live

# 클라이언트 2 (두 번째 테스트 머신)  
./dhcp-tester -server 10.0.0.1 -clients 10000 -concurrency 500 \
  -circuit-id "test-client-2" -live
```

## 2. 기본 성능 테스트

### 2.1 단계별 성능 측정

#### 기본 기능 검증
```bash
#!/bin/bash
# scenarios/basic-functionality-test.sh

echo "=== 기본 DHCP 기능 검증 ==="

# 1. 단일 클라이언트 테스트
echo "1. 단일 클라이언트 기능 검증"
./dhcp-tester -server 127.0.0.1 -clients 1 -verbose -timeout 30s

# 2. 소규모 동시 클라이언트
echo -e "\n2. 소규모 동시 클라이언트 (10개)"
./dhcp-tester -server 127.0.0.1 -clients 10 -concurrency 5 -progress

# 3. Relay Agent 기능 검증
echo -e "\n3. Relay Agent 기능 검증"
./dhcp-tester -server 127.0.0.1 -clients 5 \
  -relay -relay-ip 192.168.1.1 \
  -circuit-id "테스트/스위치/포트1" \
  -remote-id "기능검증클라이언트" \
  -verbose

# 4. 재시도 로직 검증 (정상 환경)
echo -e "\n4. 재시도 로직 검증"
./dhcp-tester -server 127.0.0.1 -clients 10 \
  -retry -max-discover-retries 2 -max-request-retries 2 \
  -initial-timeout 2s -max-timeout 8s \
  -verbose

echo "=== 기본 기능 검증 완료 ==="
```

#### 점진적 부하 증가 테스트
```bash
#!/bin/bash
# scenarios/progressive-load-test.sh

echo "=== 점진적 부하 증가 테스트 ==="

RESULTS_DIR="results/progressive-load-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$RESULTS_DIR"

# 테스트 단계별 클라이언트 수
LOAD_LEVELS=(10 25 50 100 250 500 1000 2000)

for clients in "${LOAD_LEVELS[@]}"; do
    echo "부하 레벨: $clients 클라이언트"
    
    # 동시성 계산 (클라이언트 수의 10%)
    concurrency=$((clients / 10))
    [ $concurrency -lt 5 ] && concurrency=5
    [ $concurrency -gt 200 ] && concurrency=200
    
    # 테스트 실행
    ./dhcp-tester -server 127.0.0.1 \
      -clients $clients -concurrency $concurrency \
      -timeout 30s -progress \
      > "$RESULTS_DIR/load-${clients}.log" 2>&1
    
    # 결과 추출
    if [ $? -eq 0 ]; then
        success_rate=$(grep "성공률:" "$RESULTS_DIR/load-${clients}.log" | awk '{print $2}')
        avg_time=$(grep "평균 협상 시간:" "$RESULTS_DIR/load-${clients}.log" | awk '{print $3}')
        rps=$(grep "초당 완료 수:" "$RESULTS_DIR/load-${clients}.log" | awk '{print $3}')
        
        echo "$clients,$success_rate,$avg_time,$rps" >> "$RESULTS_DIR/summary.csv"
        echo "  성공률: $success_rate, 평균시간: $avg_time, RPS: $rps"
    else
        echo "$clients,0,timeout,0" >> "$RESULTS_DIR/summary.csv"
        echo "  ❌ 테스트 실패"
    fi
    
    # 다음 테스트 전 대기
    sleep 10
done

echo "=== 점진적 부하 테스트 완료 ==="
echo "결과 요약: $RESULTS_DIR/summary.csv"
```

### 2.2 성능 벤치마크 수집

#### 표준 벤치마크 스위트
```bash
#!/bin/bash
# scenarios/benchmark-suite.sh

BENCHMARK_DIR="benchmarks/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BENCHMARK_DIR"

echo "=== DHCP 성능 벤치마크 스위트 ==="

# 시스템 정보 수집
{
    echo "=== 시스템 정보 ==="
    echo "날짜: $(date)"
    echo "호스트: $(hostname)"
    echo "OS: $(uname -a)"
    echo "CPU: $(lscpu | grep "Model name" | sed 's/Model name: *//')"
    echo "메모리: $(free -h | grep Mem | awk '{print $2}')"
    echo "Go 버전: $(go version)"
    echo ""
} > "$BENCHMARK_DIR/system-info.txt"

# 1. 처리량 벤치마크
echo "1. 처리량 벤치마크 실행 중..."
benchmark_throughput() {
    local test_name="$1"
    local clients="$2"
    local concurrency="$3"
    local description="$4"
    
    echo "벤치마크: $test_name ($description)"
    
    ./dhcp-tester -server 127.0.0.1 \
      -clients $clients -concurrency $concurrency \
      -timeout 60s -progress \
      > "$BENCHMARK_DIR/throughput-${test_name}.log" 2>&1
    
    if [ $? -eq 0 ]; then
        local rps=$(grep "초당 완료 수:" "$BENCHMARK_DIR/throughput-${test_name}.log" | awk '{print $3}')
        local success_rate=$(grep "성공률:" "$BENCHMARK_DIR/throughput-${test_name}.log" | awk '{print $2}')
        echo "$test_name,$clients,$concurrency,$rps,$success_rate,$description" >> "$BENCHMARK_DIR/throughput-results.csv"
        echo "  결과: ${rps} RPS, 성공률: ${success_rate}"
    else
        echo "  ❌ 테스트 실패"
    fi
}

# 헤더 추가
echo "test_name,clients,concurrency,rps,success_rate,description" > "$BENCHMARK_DIR/throughput-results.csv"

benchmark_throughput "small" 100 10 "소규모 환경"
benchmark_throughput "medium" 500 50 "중간 규모 환경"
benchmark_throughput "large" 1000 100 "대규모 환경"
benchmark_throughput "xlarge" 2000 200 "초대규모 환경"

# 2. 응답 시간 벤치마크
echo -e "\n2. 응답 시간 벤치마크 실행 중..."
benchmark_latency() {
    local test_name="$1"
    local clients="$2"
    local description="$3"
    
    echo "응답시간 벤치마크: $test_name ($description)"
    
    ./dhcp-tester -server 127.0.0.1 \
      -clients $clients -concurrency 1 \
      -timeout 30s -progress \
      > "$BENCHMARK_DIR/latency-${test_name}.log" 2>&1
    
    if [ $? -eq 0 ]; then
        local avg_time=$(grep "평균 협상 시간:" "$BENCHMARK_DIR/latency-${test_name}.log" | awk '{print $3}')
        local min_time=$(grep "최소 협상 시간:" "$BENCHMARK_DIR/latency-${test_name}.log" | awk '{print $3}')
        local max_time=$(grep "최대 협상 시간:" "$BENCHMARK_DIR/latency-${test_name}.log" | awk '{print $3}')
        local p95_time=$(grep "95퍼센타일:" "$BENCHMARK_DIR/latency-${test_name}.log" | awk '{print $2}')
        
        echo "$test_name,$clients,$avg_time,$min_time,$max_time,$p95_time,$description" >> "$BENCHMARK_DIR/latency-results.csv"
        echo "  평균: $avg_time, P95: $p95_time"
    else
        echo "  ❌ 테스트 실패"
    fi
}

echo "test_name,clients,avg_time,min_time,max_time,p95_time,description" > "$BENCHMARK_DIR/latency-results.csv"

benchmark_latency "sequential" 10 "순차적 요청"
benchmark_latency "low_concurrency" 50 "낮은 동시성"
benchmark_latency "high_concurrency" 100 "높은 동시성"

# 3. 재시도 로직 벤치마크
echo -e "\n3. 재시도 로직 벤치마크 실행 중..."

# 정상 환경에서의 재시도 (재시도가 발생하지 않아야 함)
./dhcp-tester -server 127.0.0.1 -clients 100 \
  -retry -max-discover-retries 3 -max-request-retries 3 \
  -progress > "$BENCHMARK_DIR/retry-normal.log" 2>&1

# 벤치마크 보고서 생성
{
    echo "=== DHCP 성능 벤치마크 보고서 ==="
    echo "생성 시간: $(date)"
    echo ""
    
    echo "== 처리량 벤치마크 =="
    cat "$BENCHMARK_DIR/throughput-results.csv" | column -t -s','
    echo ""
    
    echo "== 응답 시간 벤치마크 =="
    cat "$BENCHMARK_DIR/latency-results.csv" | column -t -s','
    echo ""
    
    echo "== 재시도 로직 결과 =="
    if [ -f "$BENCHMARK_DIR/retry-normal.log" ]; then
        grep -E "성공률|재시도|평균" "$BENCHMARK_DIR/retry-normal.log"
    fi
    
} > "$BENCHMARK_DIR/benchmark-report.txt"

echo "=== 벤치마크 스위트 완료 ==="
echo "보고서: $BENCHMARK_DIR/benchmark-report.txt"
cat "$BENCHMARK_DIR/benchmark-report.txt"
```

## 3. 실제 환경 시뮬레이션

### 3.1 기업 네트워크 시나리오

#### 사무실 환경 (200-500명)
```bash
#!/bin/bash
# scenarios/office-environment.sh

echo "=== 기업 사무실 환경 시뮬레이션 ==="

# 서버 설정 (기업 환경)
./dhcp-server -live \
  -start-ip 10.10.1.100 \
  -end-ip 10.10.1.200 \
  -gateway 10.10.1.1 \
  -dns1 10.10.1.10 \
  -dns2 8.8.8.8 \
  -domain "company.local" \
  -lease-time 8h \
  -max-concurrent 1000 &

SERVER_PID=$!
sleep 5

# 시나리오 1: 아침 출근 시간 (대량 동시 접속)
echo "시나리오 1: 아침 출근 시간 시뮬레이션"
./dhcp-tester -server 127.0.0.1 \
  -clients 200 -concurrency 50 \
  -relay -relay-ip 10.10.1.1 \
  -circuit-id "본사/3층/SW01" \
  -remote-id "직원PC" \
  -retry -timeout 15s \
  -progress

sleep 10

# 시나리오 2: 점심시간 (소규모 접속)
echo -e "\n시나리오 2: 점심시간 시뮬레이션"
./dhcp-tester -server 127.0.0.1 \
  -clients 50 -concurrency 10 \
  -relay -relay-ip 10.10.1.1 \
  -circuit-id "본사/3층/SW01" \
  -remote-id "직원PC" \
  -retry -timeout 10s \
  -progress

sleep 10

# 시나리오 3: 회의실 무선 (간헐적 접속)
echo -e "\n시나리오 3: 회의실 무선 접속 시뮬레이션"
./dhcp-tester -server 127.0.0.1 \
  -clients 30 -concurrency 5 \
  -relay -relay-ip 10.10.1.1 \
  -circuit-id "본사/4층/회의실AP" \
  -remote-id "노트북/모바일" \
  -retry -max-discover-retries 5 \
  -timeout 20s -progress

# 서버 종료
kill $SERVER_PID

echo "=== 기업 환경 시뮬레이션 완료 ==="
```

#### 대학교 기숙사 환경 (1000-2000명)
```bash
#!/bin/bash
# scenarios/university-dormitory.sh

echo "=== 대학교 기숙사 환경 시뮬레이션 ==="

# 서버 설정 (대학교 환경)
./dhcp-server -live \
  -start-ip 172.16.10.10 \
  -end-ip 172.16.20.250 \
  -gateway 172.16.10.1 \
  -dns1 172.16.1.10 \
  -dns2 168.126.63.1 \
  -domain "university.ac.kr" \
  -lease-time 12h \
  -max-concurrent 3000 &

SERVER_PID=$!
sleep 5

# 시나리오 1: 저녁 시간 (온라인 수업/게임)
echo "시나리오 1: 저녁 시간 대량 접속"
./dhcp-tester -server 127.0.0.1 \
  -clients 1500 -concurrency 150 \
  -relay -relay-ip 172.16.10.1 \
  -circuit-id "기숙사A동/4층/SW24" \
  -remote-id "학생PC" \
  -retry -max-discover-retries 3 \
  -timeout 30s -live

sleep 15

# 시나리오 2: 새벽 시간 (적은 활동)
echo -e "\n시나리오 2: 새벽 시간 저활동"
./dhcp-tester -server 127.0.0.1 \
  -clients 100 -concurrency 20 \
  -relay -relay-ip 172.16.10.1 \
  -circuit-id "기숙사A동/4층/SW24" \
  -remote-id "학생PC" \
  -retry -timeout 15s \
  -progress

# 서버 종료
kill $SERVER_PID

echo "=== 대학교 환경 시뮬레이션 완료 ==="
```

### 3.2 ISP/통신사 환경

#### FTTH 가입자 환경 (5000-10000명)
```bash
#!/bin/bash
# scenarios/isp-ftth.sh

echo "=== ISP FTTH 가입자 환경 시뮬레이션 ==="

# 서버 설정 (ISP 환경)
./dhcp-server -live \
  -start-ip 172.20.0.10 \
  -end-ip 172.20.10.250 \
  -gateway 172.20.0.1 \
  -dns1 168.126.63.1 \
  -dns2 8.8.8.8 \
  -lease-time 24h \
  -max-concurrent 15000 \
  -response-delay 20ms &  # ISP 환경의 네트워크 지연 반영

SERVER_PID=$!
sleep 5

# 시나리오 1: 출근 시간 (아침 8-9시)
echo "시나리오 1: 출근 시간 트래픽 피크"
./dhcp-tester -server 127.0.0.1 \
  -clients 8000 -concurrency 400 \
  -relay -relay-ip 203.0.113.1 \
  -circuit-id "OLT-seoul-01/PON-24" \
  -remote-id "아파트단지A" \
  -retry -max-discover-retries 4 \
  -initial-timeout 6s -max-timeout 64s \
  -timeout 120s -live

sleep 30

# 시나리오 2: 저녁 시간 (오후 7-9시)
echo -e "\n시나리오 2: 저녁 시간 인터넷 사용 피크"
./dhcp-tester -server 127.0.0.1 \
  -clients 10000 -concurrency 500 \
  -relay -relay-ip 203.0.113.1 \
  -circuit-id "OLT-seoul-01/PON-24" \
  -remote-id "아파트단지A" \
  -retry -max-discover-retries 4 \
  -initial-timeout 6s -max-timeout 64s \
  -timeout 150s -live

# 서버 종료
kill $SERVER_PID

echo "=== ISP FTTH 환경 시뮬레이션 완료 ==="
```

#### 케이블 모뎀 환경
```bash
#!/bin/bash
# scenarios/cable-modem.sh

echo "=== 케이블 모뎀 환경 시뮬레이션 ==="

# 서버 설정 (케이블 환경 - 공유 대역폭으로 인한 지연)
./dhcp-server -live \
  -start-ip 10.1.0.10 \
  -end-ip 10.1.50.250 \
  -gateway 10.1.0.1 \
  -lease-time 72h \
  -max-concurrent 8000 \
  -response-delay 50ms \
  -drop-rate 0.005 &  # 약간의 패킷 손실 시뮬레이션

SERVER_PID=$!
sleep 5

# 시나리오: 공유 대역폭 환경에서의 DHCP 성능
echo "케이블 모뎀 환경 - 공유 대역폭 시뮬레이션"
./dhcp-tester -server 127.0.0.1 \
  -clients 5000 -concurrency 200 \
  -relay -relay-ip 192.168.100.1 \
  -circuit-id "CMTS-01/DS-12/US-4" \
  -remote-id "케이블모뎀" \
  -retry -max-discover-retries 5 \
  -initial-timeout 8s -max-timeout 64s \
  -timeout 180s -live

kill $SERVER_PID

echo "=== 케이블 모뎀 환경 시뮬레이션 완료 ==="
```

## 4. 스트레스 테스트

### 4.1 극한 부하 테스트

#### 최대 동시 연결 테스트
```bash
#!/bin/bash
# scenarios/max-concurrent-test.sh

echo "=== 최대 동시 연결 스트레스 테스트 ==="

STRESS_DIR="stress-test-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$STRESS_DIR"

# 대용량 IP 풀로 서버 시작
./dhcp-server -live \
  -start-ip 10.0.0.10 \
  -end-ip 10.0.255.250 \
  -max-concurrent 50000 \
  -lease-time 1h &

SERVER_PID=$!
sleep 10

# 단계별 동시 연결 수 증가
CONCURRENT_LEVELS=(100 500 1000 2000 5000 10000 20000)

for concurrent in "${CONCURRENT_LEVELS[@]}"; do
    echo "동시 연결 테스트: $concurrent"
    
    # 클라이언트 수는 동시 연결의 2배로 설정
    clients=$((concurrent * 2))
    
    timeout 300s ./dhcp-tester -server 127.0.0.1 \
      -clients $clients -concurrency $concurrent \
      -retry -timeout 60s \
      > "$STRESS_DIR/concurrent-${concurrent}.log" 2>&1
    
    exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        success_rate=$(grep "성공률:" "$STRESS_DIR/concurrent-${concurrent}.log" | awk '{print $2}')
        rps=$(grep "초당 완료 수:" "$STRESS_DIR/concurrent-${concurrent}.log" | awk '{print $3}')
        echo "  ✅ 성공: 성공률 $success_rate, RPS $rps"
        echo "$concurrent,$clients,$success_rate,$rps,SUCCESS" >> "$STRESS_DIR/concurrent-results.csv"
    else
        echo "  ❌ 실패 또는 타임아웃"
        echo "$concurrent,$clients,0,0,FAILED" >> "$STRESS_DIR/concurrent-results.csv"
        
        # 실패 시 더 이상 증가시키지 않음
        echo "최대 동시 연결 한계점 도달: $concurrent"
        break
    fi
    
    # 시스템 안정화를 위한 대기
    sleep 30
done

kill $SERVER_PID

echo "=== 최대 동시 연결 테스트 완료 ==="
echo "결과: $STRESS_DIR/concurrent-results.csv"
```

#### 메모리 사용량 스트레스 테스트
```bash
#!/bin/bash
# scenarios/memory-stress-test.sh

echo "=== 메모리 사용량 스트레스 테스트 ==="

MEMORY_DIR="memory-stress-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$MEMORY_DIR"

# 메모리 모니터링 함수
monitor_memory() {
    local duration="$1"
    local output_file="$2"
    
    echo "timestamp,dhcp_memory_mb,total_memory_mb,memory_percent" > "$output_file"
    
    for ((i=0; i<duration; i+=5)); do
        local dhcp_pid=$(pgrep -f dhcp-server)
        if [ -n "$dhcp_pid" ]; then
            local dhcp_memory=$(ps -p "$dhcp_pid" -o rss= | awk '{print int($1/1024)}')
            local total_memory=$(free -m | grep Mem | awk '{print $2}')
            local memory_percent=$(echo "scale=1; $dhcp_memory * 100 / $total_memory" | bc)
            
            echo "$(date +%s),$dhcp_memory,$total_memory,$memory_percent" >> "$output_file"
        fi
        sleep 5
    done
}

# 서버 시작
./dhcp-server -live \
  -start-ip 10.0.0.10 \
  -end-ip 10.0.100.250 \
  -max-concurrent 20000 \
  -lease-time 30m &

SERVER_PID=$!
sleep 10

# 메모리 모니터링 시작 (백그라운드)
monitor_memory 1800 "$MEMORY_DIR/memory-usage.csv" &
MONITOR_PID=$!

# 단계적 메모리 압박 테스트
echo "1단계: 기본 부하 (1000 클라이언트)"
./dhcp-tester -server 127.0.0.1 -clients 1000 -concurrency 100 -progress

sleep 60

echo "2단계: 중간 부하 (5000 클라이언트)"
./dhcp-tester -server 127.0.0.1 -clients 5000 -concurrency 200 -progress

sleep 60

echo "3단계: 높은 부하 (10000 클라이언트)"
./dhcp-tester -server 127.0.0.1 -clients 10000 -concurrency 300 -progress

sleep 60

echo "4단계: 극한 부하 (20000 클라이언트)"
./dhcp-tester -server 127.0.0.1 -clients 20000 -concurrency 400 -timeout 120s -progress

# 30분간 지속적인 부하 유지
echo "5단계: 지속적 부하 (30분간)"
for i in {1..6}; do
    echo "  지속 테스트 $i/6"
    ./dhcp-tester -server 127.0.0.1 -clients 5000 -concurrency 200 -progress
    sleep 60
done

# 모니터링 종료
kill $MONITOR_PID $SERVER_PID

# 메모리 사용량 분석
echo "=== 메모리 사용량 분석 ==="
if [ -f "$MEMORY_DIR/memory-usage.csv" ]; then
    max_memory=$(tail -n +2 "$MEMORY_DIR/memory-usage.csv" | cut -d, -f2 | sort -n | tail -1)
    avg_memory=$(tail -n +2 "$MEMORY_DIR/memory-usage.csv" | cut -d, -f2 | awk '{sum+=$1} END {print int(sum/NR)}')
    
    echo "최대 메모리 사용량: ${max_memory}MB"
    echo "평균 메모리 사용량: ${avg_memory}MB"
    echo "상세 데이터: $MEMORY_DIR/memory-usage.csv"
fi

echo "=== 메모리 스트레스 테스트 완료 ==="
```

### 4.2 장시간 안정성 테스트

#### 24시간 지속성 테스트
```bash
#!/bin/bash
# scenarios/endurance-test.sh

echo "=== 24시간 지속성 테스트 ==="

ENDURANCE_DIR="endurance-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$ENDURANCE_DIR"

# 서버 시작
./dhcp-server -live \
  -start-ip 172.16.0.10 \
  -end-ip 172.16.10.250 \
  -lease-time 6h \
  -max-concurrent 5000 \
  > "$ENDURANCE_DIR/server.log" 2>&1 &

SERVER_PID=$!
sleep 10

# 24시간 = 1440분 = 288번 (5분마다)
TOTAL_CYCLES=288
CURRENT_CYCLE=0

echo "24시간 지속성 테스트 시작 (5분 간격, 총 $TOTAL_CYCLES 사이클)"
echo "시작 시간: $(date)"

while [ $CURRENT_CYCLE -lt $TOTAL_CYCLES ]; do
    ((CURRENT_CYCLE++))
    
    echo "[$(date)] 사이클 $CURRENT_CYCLE/$TOTAL_CYCLES"
    
    # 다양한 부하 패턴 시뮬레이션
    hour=$(date +%H)
    
    if [ $hour -ge 9 ] && [ $hour -le 18 ]; then
        # 업무 시간: 높은 부하
        clients=2000
        concurrency=100
        pattern="업무시간"
    elif [ $hour -ge 19 ] && [ $hour -le 23 ]; then
        # 저녁 시간: 중간 부하
        clients=1000
        concurrency=50
        pattern="저녁시간"
    else
        # 새벽/밤: 낮은 부하
        clients=200
        concurrency=20
        pattern="심야시간"
    fi
    
    # 테스트 실행
    timeout 300s ./dhcp-tester -server 127.0.0.1 \
      -clients $clients -concurrency $concurrency \
      -retry -timeout 60s \
      > "$ENDURANCE_DIR/cycle-${CURRENT_CYCLE}.log" 2>&1
    
    # 결과 기록
    if [ $? -eq 0 ]; then
        success_rate=$(grep "성공률:" "$ENDURANCE_DIR/cycle-${CURRENT_CYCLE}.log" | awk '{print $2}' | sed 's/%//')
        avg_time=$(grep "평균 협상 시간:" "$ENDURANCE_DIR/cycle-${CURRENT_CYCLE}.log" | awk '{print $3}')
        
        echo "$(date +%s),$CURRENT_CYCLE,$pattern,$clients,$concurrency,$success_rate,$avg_time,SUCCESS" >> "$ENDURANCE_DIR/endurance-log.csv"
        echo "  성공: $success_rate 성공률, $avg_time 평균시간"
    else
        echo "$(date +%s),$CURRENT_CYCLE,$pattern,$clients,$concurrency,0,timeout,FAILED" >> "$ENDURANCE_DIR/endurance-log.csv"
        echo "  실패 또는 타임아웃"
    fi
    
    # 서버 상태 확인
    if ! kill -0 $SERVER_PID 2>/dev/null; then
        echo "❌ 서버 프로세스가 중지됨! 테스트 중단"
        break
    fi
    
    # 메모리 사용량 기록
    dhcp_memory=$(ps -p $SERVER_PID -o rss= 2>/dev/null | awk '{print int($1/1024)}' || echo "0")
    echo "$(date +%s),$CURRENT_CYCLE,$dhcp_memory" >> "$ENDURANCE_DIR/memory-log.csv"
    
    # 다음 사이클까지 대기 (5분)
    sleep 300
done

# 서버 종료
kill $SERVER_PID

echo "=== 24시간 지속성 테스트 완료 ==="
echo "종료 시간: $(date)"
echo "로그 디렉토리: $ENDURANCE_DIR"

# 결과 분석
if [ -f "$ENDURANCE_DIR/endurance-log.csv" ]; then
    total_cycles=$(wc -l < "$ENDURANCE_DIR/endurance-log.csv")
    success_cycles=$(grep "SUCCESS" "$ENDURANCE_DIR/endurance-log.csv" | wc -l)
    overall_success_rate=$((success_cycles * 100 / total_cycles))
    
    echo "전체 성공률: $overall_success_rate% ($success_cycles/$total_cycles)"
fi
```

## 5. 네트워크 장애 시나리오

### 5.1 패킷 손실 시뮬레이션

#### 다양한 손실률에서의 재시도 효과
```bash
#!/bin/bash
# scenarios/packet-loss-test.sh

echo "=== 패킷 손실 재시도 로직 테스트 ==="

LOSS_DIR="packet-loss-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$LOSS_DIR"

# 다양한 패킷 손실률
LOSS_RATES=(0.0 0.01 0.02 0.05 0.1 0.15 0.2)

echo "drop_rate,no_retry_success,retry_success,improvement" > "$LOSS_DIR/comparison.csv"

for loss_rate in "${LOSS_RATES[@]}"; do
    echo "패킷 손실률: ${loss_rate} ($(echo "$loss_rate * 100" | bc)%)"
    
    # 서버 시작 (패킷 손실 설정)
    ./dhcp-server -live \
      -start-ip 192.168.100.10 \
      -end-ip 192.168.100.250 \
      -drop-rate $loss_rate \
      -response-delay 50ms &
    
    SERVER_PID=$!
    sleep 5
    
    # 1. 재시도 없이 테스트
    echo "  재시도 비활성화 테스트..."
    ./dhcp-tester -server 127.0.0.1 \
      -clients 200 -concurrency 20 \
      -timeout 10s -progress \
      > "$LOSS_DIR/no-retry-${loss_rate}.log" 2>&1
    
    no_retry_success=$(grep "성공률:" "$LOSS_DIR/no-retry-${loss_rate}.log" | awk '{print $2}' | sed 's/%//' || echo "0")
    
    sleep 10
    
    # 2. 재시도 활성화 테스트  
    echo "  재시도 활성화 테스트..."
    ./dhcp-tester -server 127.0.0.1 \
      -clients 200 -concurrency 20 \
      -retry -max-discover-retries 5 -max-request-retries 5 \
      -initial-timeout 2s -max-timeout 32s \
      -timeout 60s -progress \
      > "$LOSS_DIR/retry-${loss_rate}.log" 2>&1
    
    retry_success=$(grep "성공률:" "$LOSS_DIR/retry-${loss_rate}.log" | awk '{print $2}' | sed 's/%//' || echo "0")
    
    # 개선률 계산
    if [ "$no_retry_success" != "0" ]; then
        improvement=$(echo "scale=1; $retry_success - $no_retry_success" | bc)
    else
        improvement=$retry_success
    fi
    
    echo "$loss_rate,$no_retry_success,$retry_success,$improvement" >> "$LOSS_DIR/comparison.csv"
    echo "  결과: 재시도 없음=${no_retry_success}%, 재시도 있음=${retry_success}%, 개선=${improvement}%"
    
    kill $SERVER_PID
    sleep 5
done

# 결과 분석 보고서
{
    echo "=== 패킷 손실 재시도 로직 효과 분석 ==="
    echo "테스트 시간: $(date)"
    echo ""
    
    echo "상세 결과:"
    cat "$LOSS_DIR/comparison.csv" | column -t -s','
    echo ""
    
    echo "주요 발견사항:"
    # 가장 큰 개선을 보인 손실률 찾기
    best_improvement=$(tail -n +2 "$LOSS_DIR/comparison.csv" | sort -t, -k4 -nr | head -1)
    echo "- 최대 개선 효과: $best_improvement"
    
    # 재시도 로직이 효과적인 임계점 찾기
    effective_threshold=$(tail -n +2 "$LOSS_DIR/comparison.csv" | awk -F, '$4 > 10 {print $1}' | head -1)
    if [ -n "$effective_threshold" ]; then
        echo "- 재시도 로직 효과적 임계점: 패킷 손실률 ${effective_threshold}% 이상"
    fi
    
} > "$LOSS_DIR/analysis-report.txt"

echo "=== 패킷 손실 테스트 완료 ==="
echo "보고서: $LOSS_DIR/analysis-report.txt"
cat "$LOSS_DIR/analysis-report.txt"
```

### 5.2 네트워크 지연 시나리오

#### 다양한 지연 환경에서의 성능
```bash
#!/bin/bash
# scenarios/network-latency-test.sh

echo "=== 네트워크 지연 성능 테스트 ==="

LATENCY_DIR="network-latency-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$LATENCY_DIR"

# 다양한 네트워크 지연 (밀리초)
DELAY_VALUES=(0 10 50 100 200 500 1000)

echo "delay_ms,avg_response_time,success_rate,rps,timeout_adjusted" > "$LATENCY_DIR/latency-results.csv"

for delay in "${DELAY_VALUES[@]}"; do
    echo "네트워크 지연: ${delay}ms"
    
    # 지연에 따른 적응적 타임아웃 계산
    if [ $delay -le 50 ]; then
        timeout="30s"
        max_timeout="16s"
    elif [ $delay -le 200 ]; then
        timeout="60s"
        max_timeout="32s"
    else
        timeout="120s"
        max_timeout="64s"
    fi
    
    # 서버 시작 (지연 설정)
    ./dhcp-server -live \
      -start-ip 192.168.100.10 \
      -end-ip 192.168.100.250 \
      -response-delay ${delay}ms &
    
    SERVER_PID=$!
    sleep 5
    
    # 적응적 재시도 설정으로 테스트
    ./dhcp-tester -server 127.0.0.1 \
      -clients 100 -concurrency 20 \
      -retry -max-discover-retries 3 -max-request-retries 3 \
      -initial-timeout 4s -max-timeout $max_timeout \
      -timeout $timeout -progress \
      > "$LATENCY_DIR/delay-${delay}ms.log" 2>&1
    
    # 결과 추출
    if [ $? -eq 0 ]; then
        avg_time=$(grep "평균 협상 시간:" "$LATENCY_DIR/delay-${delay}ms.log" | awk '{print $3}')
        success_rate=$(grep "성공률:" "$LATENCY_DIR/delay-${delay}ms.log" | awk '{print $2}' | sed 's/%//')
        rps=$(grep "초당 완료 수:" "$LATENCY_DIR/delay-${delay}ms.log" | awk '{print $3}')
        
        echo "$delay,$avg_time,$success_rate,$rps,$timeout" >> "$LATENCY_DIR/latency-results.csv"
        echo "  평균 응답: $avg_time, 성공률: ${success_rate}%, RPS: $rps"
    else
        echo "$delay,timeout,0,0,$timeout" >> "$LATENCY_DIR/latency-results.csv"
        echo "  테스트 실패 또는 타임아웃"
    fi
    
    kill $SERVER_PID
    sleep 5
done

# 지연별 성능 영향 분석
{
    echo "=== 네트워크 지연 성능 영향 분석 ==="
    echo "테스트 시간: $(date)"
    echo ""
    
    echo "지연별 성능 결과:"
    cat "$LATENCY_DIR/latency-results.csv" | column -t -s','
    echo ""
    
    echo "성능 영향 분석:"
    baseline_rps=$(head -2 "$LATENCY_DIR/latency-results.csv" | tail -1 | cut -d, -f4)
    
    tail -n +2 "$LATENCY_DIR/latency-results.csv" | while IFS=, read delay avg_time success_rate rps timeout; do
        if [ "$rps" != "0" ] && [ "$rps" != "timeout" ]; then
            if [ "$baseline_rps" != "0" ]; then
                performance_impact=$(echo "scale=1; ($baseline_rps - $rps) * 100 / $baseline_rps" | bc)
                echo "- ${delay}ms 지연: 성능 저하 ${performance_impact}%"
            fi
        fi
    done
    
} > "$LATENCY_DIR/latency-analysis.txt"

echo "=== 네트워크 지연 테스트 완료 ==="
echo "분석 보고서: $LATENCY_DIR/latency-analysis.txt"
cat "$LATENCY_DIR/latency-analysis.txt"
```

## 6. 벤치마크 기준

### 6.1 성능 기준표

#### 표준 성능 지표
```bash
#!/bin/bash
# scenarios/benchmark-standards.sh

cat << 'EOF'
=== DHCP 성능 테스트 표준 기준표 ===

1. 응답 시간 기준 (완전한 DHCP 협상)
   - 우수: < 50ms
   - 양호: 50ms - 100ms  
   - 보통: 100ms - 200ms
   - 부족: 200ms - 500ms
   - 불량: > 500ms

2. 처리량 기준 (초당 완료 수)
   - 소규모 환경 (< 500 클라이언트):
     * 우수: > 100 completions/sec
     * 양호: 50-100 completions/sec
     * 보통: 20-50 completions/sec
     
   - 중간 규모 환경 (500-2000 클라이언트):
     * 우수: > 500 completions/sec
     * 양호: 200-500 completions/sec
     * 보통: 100-200 completions/sec
     
   - 대규모 환경 (> 2000 클라이언트):
     * 우수: > 1000 completions/sec
     * 양호: 500-1000 completions/sec
     * 보통: 200-500 completions/sec

3. 성공률 기준
   - 정상 환경: > 99%
   - 불안정 환경 (5% 패킷 손실): > 95%
   - 매우 불안정 환경 (10% 패킷 손실): > 85%

4. 리소스 사용률 기준
   - 메모리: < 2MB per 1000 클라이언트
   - CPU: < 50% (정상 부하 시)
   - 파일 디스크립터: < 1000개

5. 재시도 효과성 기준
   - 5% 패킷 손실 환경: > 20% 성공률 개선
   - 10% 패킷 손실 환경: > 40% 성공률 개선

6. 환경별 권장 설정
   
   기업 네트워크 (< 1000 클라이언트):
   - 동시성: 50-100
   - 타임아웃: 15-30초
   - 재시도: Discover 3회, Request 3회
   
   ISP 환경 (> 5000 클라이언트):
   - 동시성: 200-500
   - 타임아웃: 30-60초  
   - 재시도: Discover 4회, Request 4회
   
   불안정 네트워크:
   - 동시성: 낮게 설정 (< 50)
   - 타임아웃: 60-120초
   - 재시도: Discover 5회, Request 5회

=== 벤치마크 기준표 끝 ===
EOF
```

### 6.2 자동 성능 평가

#### 성능 등급 자동 평가 스크립트
```bash
#!/bin/bash
# scenarios/performance-grade.sh

echo "=== 자동 성능 등급 평가 ==="

GRADE_DIR="performance-grade-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$GRADE_DIR"

# 서버 시작
./dhcp-server -live \
  -start-ip 192.168.100.10 \
  -end-ip 192.168.100.250 \
  -max-concurrent 2000 &

SERVER_PID=$!
sleep 5

# 표준 벤치마크 테스트 실행
echo "표준 벤치마크 테스트 실행 중..."

# 1. 응답 시간 테스트
./dhcp-tester -server 127.0.0.1 \
  -clients 100 -concurrency 1 \
  -timeout 30s -progress \
  > "$GRADE_DIR/response-time.log" 2>&1

# 2. 처리량 테스트
./dhcp-tester -server 127.0.0.1 \
  -clients 500 -concurrency 50 \
  -timeout 60s -progress \
  > "$GRADE_DIR/throughput.log" 2>&1

# 3. 재시도 효과 테스트 (서버 재시작 필요)
kill $SERVER_PID
sleep 2

./dhcp-server -live \
  -start-ip 192.168.100.10 \
  -end-ip 192.168.100.250 \
  -drop-rate 0.05 &

SERVER_PID=$!
sleep 5

./dhcp-tester -server 127.0.0.1 \
  -clients 200 -concurrency 20 \
  -retry -max-discover-retries 3 -max-request-retries 3 \
  -timeout 60s -progress \
  > "$GRADE_DIR/retry-effectiveness.log" 2>&1

kill $SERVER_PID

# 결과 분석 및 등급 부여
evaluate_performance() {
    # 응답 시간 등급
    avg_response=$(grep "평균 협상 시간:" "$GRADE_DIR/response-time.log" | awk '{print $3}' | sed 's/[a-z]*$//')
    
    if [ -n "$avg_response" ]; then
        if (( $(echo "$avg_response < 50" | bc -l) )); then
            response_grade="A"
            response_score=100
        elif (( $(echo "$avg_response < 100" | bc -l) )); then
            response_grade="B"
            response_score=85
        elif (( $(echo "$avg_response < 200" | bc -l) )); then
            response_grade="C"
            response_score=70
        elif (( $(echo "$avg_response < 500" | bc -l) )); then
            response_grade="D"
            response_score=55
        else
            response_grade="F"
            response_score=30
        fi
    else
        response_grade="N/A"
        response_score=0
    fi
    
    # 처리량 등급
    throughput=$(grep "초당 완료 수:" "$GRADE_DIR/throughput.log" | awk '{print $3}' | sed 's/[^0-9.]//g')
    
    if [ -n "$throughput" ]; then
        if (( $(echo "$throughput > 500" | bc -l) )); then
            throughput_grade="A"
            throughput_score=100
        elif (( $(echo "$throughput > 200" | bc -l) )); then
            throughput_grade="B"
            throughput_score=85
        elif (( $(echo "$throughput > 100" | bc -l) )); then
            throughput_grade="C"
            throughput_score=70
        elif (( $(echo "$throughput > 50" | bc -l) )); then
            throughput_grade="D"
            throughput_score=55
        else
            throughput_grade="F"
            throughput_score=30
        fi
    else
        throughput_grade="N/A"
        throughput_score=0
    fi
    
    # 안정성 등급 (재시도 환경에서의 성공률)
    stability=$(grep "성공률:" "$GRADE_DIR/retry-effectiveness.log" | awk '{print $2}' | sed 's/%//')
    
    if [ -n "$stability" ]; then
        if (( $(echo "$stability > 95" | bc -l) )); then
            stability_grade="A"
            stability_score=100
        elif (( $(echo "$stability > 90" | bc -l) )); then
            stability_grade="B"
            stability_score=85
        elif (( $(echo "$stability > 85" | bc -l) )); then
            stability_grade="C"
            stability_score=70
        elif (( $(echo "$stability > 70" | bc -l) )); then
            stability_grade="D"
            stability_score=55
        else
            stability_grade="F"
            stability_score=30
        fi
    else
        stability_grade="N/A"
        stability_score=0
    fi
    
    # 전체 점수 계산 (가중 평균)
    overall_score=$(echo "scale=1; ($response_score * 0.4 + $throughput_score * 0.4 + $stability_score * 0.2)" | bc)
    
    if (( $(echo "$overall_score >= 90" | bc -l) )); then
        overall_grade="A"
    elif (( $(echo "$overall_score >= 80" | bc -l) )); then
        overall_grade="B"
    elif (( $(echo "$overall_score >= 70" | bc -l) )); then
        overall_grade="C"
    elif (( $(echo "$overall_score >= 60" | bc -l) )); then
        overall_grade="D"
    else
        overall_grade="F"
    fi
    
    # 성능 보고서 생성
    {
        echo "=== DHCP 성능 등급 평가 보고서 ==="
        echo "평가 시간: $(date)"
        echo "테스트 환경: $(hostname)"
        echo ""
        
        echo "상세 평가 결과:"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        printf "%-20s %-10s %-15s %-10s\n" "평가 항목" "측정값" "등급" "점수"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        printf "%-20s %-10s %-15s %-10s\n" "응답 시간" "${avg_response}ms" "$response_grade" "$response_score"
        printf "%-20s %-10s %-15s %-10s\n" "처리량" "${throughput} RPS" "$throughput_grade" "$throughput_score"
        printf "%-20s %-10s %-15s %-10s\n" "안정성" "${stability}%" "$stability_grade" "$stability_score"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        printf "%-20s %-10s %-15s %-10s\n" "종합 평가" "-" "$overall_grade" "$overall_score"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        
        echo "등급별 의미:"
        echo "A: 우수 (90점 이상) - 프로덕션 환경에 최적"
        echo "B: 양호 (80-89점) - 일반적인 환경에 적합"
        echo "C: 보통 (70-79점) - 개선 권장"
        echo "D: 부족 (60-69점) - 설정 조정 필요"
        echo "F: 불량 (60점 미만) - 시스템 점검 필요"
        echo ""
        
        # 개선 권장사항
        echo "개선 권장사항:"
        if [ "$response_grade" != "A" ]; then
            echo "- 응답 시간 개선: 네트워크 지연 확인, 타임아웃 조정"
        fi
        if [ "$throughput_grade" != "A" ]; then
            echo "- 처리량 개선: 동시성 증가, 시스템 리소스 확장"
        fi
        if [ "$stability_grade" != "A" ]; then
            echo "- 안정성 개선: 재시도 설정 조정, 네트워크 품질 개선"
        fi
        
    } > "$GRADE_DIR/performance-report.txt"
}

evaluate_performance

echo "=== 성능 등급 평가 완료 ==="
echo "보고서: $GRADE_DIR/performance-report.txt"
cat "$GRADE_DIR/performance-report.txt"
```

## 7. 성능 분석 및 리포팅

### 7.1 통합 성능 분석 도구

#### 종합 성능 분석 스크립트
```bash
#!/bin/bash
# scenarios/comprehensive-analysis.sh

echo "=== 종합 성능 분석 도구 ==="

ANALYSIS_DIR="comprehensive-analysis-$(date +%Y%m%d_%H%M%S)"
mkdir -p "$ANALYSIS_DIR"

# 1. 시스템 환경 정보 수집
collect_system_info() {
    {
        echo "=== 시스템 환경 정보 ==="
        echo "수집 시간: $(date)"
        echo ""
        
        echo "하드웨어 정보:"
        echo "CPU: $(lscpu | grep "Model name" | sed 's/Model name: *//')"
        echo "코어 수: $(nproc)"
        echo "메모리: $(free -h | grep Mem | awk '{print $2}')"
        echo "디스크: $(df -h / | tail -1 | awk '{print $4}') 여유공간"
        echo ""
        
        echo "네트워크 정보:"
        ip addr show | grep -E "^[0-9]|inet " | head -10
        echo ""
        
        echo "소프트웨어 정보:"
        echo "OS: $(uname -a)"
        echo "Go 버전: $(go version)"
        echo "빌드 정보: $(./dhcp-tester -h 2>&1 | head -1 || echo "버전 정보 없음")"
        
    } > "$ANALYSIS_DIR/system-info.txt"
}

# 2. 다양한 시나리오 테스트 실행
run_test_scenarios() {
    echo "다양한 시나리오 테스트 실행 중..."
    
    # 서버 시작
    ./dhcp-server -live \
      -start-ip 10.0.1.10 \
      -end-ip 10.0.10.250 \
      -max-concurrent 5000 \
      > "$ANALYSIS_DIR/server.log" 2>&1 &
    
    SERVER_PID=$!
    sleep 10
    
    # 시나리오 1: 기본 성능
    echo "  시나리오 1: 기본 성능 테스트"
    ./dhcp-tester -server 127.0.0.1 \
      -clients 500 -concurrency 50 \
      -timeout 30s -progress \
      > "$ANALYSIS_DIR/scenario1-basic.log" 2>&1
    
    sleep 10
    
    # 시나리오 2: 고부하
    echo "  시나리오 2: 고부하 테스트"  
    ./dhcp-tester -server 127.0.0.1 \
      -clients 2000 -concurrency 200 \
      -timeout 60s -progress \
      > "$ANALYSIS_DIR/scenario2-high-load.log" 2>&1
    
    sleep 10
    
    # 시나리오 3: Relay Agent
    echo "  시나리오 3: Relay Agent 테스트"
    ./dhcp-tester -server 127.0.0.1 \
      -clients 1000 -concurrency 100 \
      -relay -relay-ip 10.0.1.1 \
      -circuit-id "분석테스트/스위치" \
      -timeout 45s -progress \
      > "$ANALYSIS_DIR/scenario3-relay.log" 2>&1
    
    kill $SERVER_PID
    sleep 5
    
    # 시나리오 4: 불안정 네트워크
    echo "  시나리오 4: 불안정 네트워크 테스트"
    ./dhcp-server -live \
      -start-ip 10.0.1.10 \
      -end-ip 10.0.5.250 \
      -drop-rate 0.05 \
      -response-delay 100ms \
      > "$ANALYSIS_DIR/server-unstable.log" 2>&1 &
    
    SERVER_PID=$!
    sleep 5
    
    ./dhcp-tester -server 127.0.0.1 \
      -clients 500 -concurrency 50 \
      -retry -max-discover-retries 5 -max-request-retries 5 \
      -initial-timeout 3s -max-timeout 30s \
      -timeout 120s -progress \
      > "$ANALYSIS_DIR/scenario4-unstable.log" 2>&1
    
    kill $SERVER_PID
}

# 3. 결과 분석 및 보고서 생성
analyze_results() {
    echo "결과 분석 중..."
    
    {
        echo "=== 종합 성능 분석 보고서 ==="
        echo "분석 시간: $(date)"
        echo "테스트 환경: $(hostname)"
        echo ""
        
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "시나리오별 성능 결과"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        printf "%-20s %-15s %-15s %-15s %-15s\n" "시나리오" "성공률" "평균응답시간" "RPS" "특이사항"
        echo "────────────────────────────────────────────────────────────────────────────"
        
        # 각 시나리오 결과 파싱
        for scenario in basic high-load relay unstable; do
            log_file="$ANALYSIS_DIR/scenario*-${scenario}.log"
            
            if ls $log_file >/dev/null 2>&1; then
                success_rate=$(grep "성공률:" $log_file | awk '{print $2}' || echo "N/A")
                avg_time=$(grep "평균 협상 시간:" $log_file | awk '{print $3}' || echo "N/A")
                rps=$(grep "초당 완료 수:" $log_file | awk '{print $3}' || echo "N/A")
                
                case $scenario in
                    "basic") scenario_name="기본 성능" ;;
                    "high-load") scenario_name="고부하" ;;
                    "relay") scenario_name="Relay Agent" ;;
                    "unstable") scenario_name="불안정 네트워크" ;;
                esac
                
                # 특이사항 확인
                notes=""
                if [ "$scenario" = "unstable" ]; then
                    retry_count=$(grep -c "재시도" $log_file || echo "0")
                    if [ "$retry_count" -gt 0 ]; then
                        notes="재시도 발생"
                    fi
                fi
                
                printf "%-20s %-15s %-15s %-15s %-15s\n" "$scenario_name" "$success_rate" "$avg_time" "$rps" "$notes"
            fi
        done
        
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "성능 트렌드 분석"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # 부하 증가에 따른 성능 변화
        basic_rps=$(grep "초당 완료 수:" "$ANALYSIS_DIR"/scenario1-basic.log | awk '{print $3}' | sed 's/[^0-9.]//g' || echo "0")
        high_rps=$(grep "초당 완료 수:" "$ANALYSIS_DIR"/scenario2-high-load.log | awk '{print $3}' | sed 's/[^0-9.]//g' || echo "0")
        
        if [ "$basic_rps" != "0" ] && [ "$high_rps" != "0" ]; then
            scalability=$(echo "scale=1; $high_rps / $basic_rps" | bc)
            echo "확장성 지수: ${scalability} (4배 부하 증가 시 처리량 비율)"
            
            if (( $(echo "$scalability > 2.0" | bc -l) )); then
                echo "확장성 평가: 우수 - 부하 증가에도 성능 유지"
            elif (( $(echo "$scalability > 1.5" | bc -l) )); then
                echo "확장성 평가: 양호 - 적절한 확장성"
            else
                echo "확장성 평가: 개선 필요 - 부하 증가 시 성능 저하"
            fi
        fi
        
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "권장사항"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        
        # 성능 기반 권장사항 생성
        if [ "$basic_rps" != "0" ]; then
            if (( $(echo "$basic_rps < 100" | bc -l) )); then
                echo "• 처리량 개선이 필요합니다 (현재: ${basic_rps} RPS)"
                echo "  - 시스템 리소스 확장 고려"
                echo "  - 네트워크 설정 최적화"
            fi
        fi
        
        # 불안정 네트워크 결과 확인
        unstable_success=$(grep "성공률:" "$ANALYSIS_DIR"/scenario4-unstable.log | awk '{print $2}' | sed 's/%//' || echo "0")
        if [ "$unstable_success" != "0" ]; then
            if (( $(echo "$unstable_success < 90" | bc -l) )); then
                echo "• 네트워크 안정성 개선이 필요합니다 (불안정 환경 성공률: ${unstable_success}%)"
                echo "  - 재시도 설정 조정"
                echo "  - 타임아웃 값 증가"
            fi
        fi
        
        echo ""
        echo "상세 로그 파일:"
        ls -la "$ANALYSIS_DIR"/*.log
        
    } > "$ANALYSIS_DIR/comprehensive-report.txt"
}

# 메인 실행
main() {
    echo "종합 성능 분석 시작..."
    
    collect_system_info
    run_test_scenarios  
    analyze_results
    
    echo "=== 종합 성능 분석 완료 ==="
    echo "보고서: $ANALYSIS_DIR/comprehensive-report.txt"
    echo ""
    cat "$ANALYSIS_DIR/comprehensive-report.txt"
}

main "$@"
```

---

이 테스트 시나리오 및 벤치마크 가이드를 통해 다양한 환경에서 DHCP 서버의 성능을 체계적으로 평가하고, 최적의 설정을 찾을 수 있습니다.