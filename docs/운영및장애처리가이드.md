# DHCP 성능 테스트 솔루션 운영 및 트러블슈팅 가이드

## 📋 목차
1. [운영 가이드](#1-운영-가이드)
2. [모니터링 및 알림](#2-모니터링-및-알림)
3. [트러블슈팅](#3-트러블슈팅)
4. [성능 최적화](#4-성능-최적화)
5. [보안 운영](#5-보안-운영)
6. [백업 및 복구](#6-백업-및-복구)
7. [운영 자동화](#7-운영-자동화)

## 1. 운영 가이드

### 1.1 일상 운영 절차

#### 시스템 상태 확인
```bash
#!/bin/bash
# scripts/daily-check.sh

echo "=== DHCP 테스트 시스템 일일 점검 ==="
echo "점검 시간: $(date)"

# 1. 시스템 리소스 확인
echo -e "\n🔍 시스템 리소스 현황:"
echo "CPU 사용률: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%"
echo "메모리 사용률: $(free | grep Mem | awk '{printf("%.1f%%\n", $3/$2 * 100.0)}')"
echo "디스크 사용률: $(df -h / | tail -1 | awk '{print $5}')"

# 2. 프로세스 상태 확인
echo -e "\n📊 프로세스 상태:"
if pgrep -f dhcp-server > /dev/null; then
    echo "✅ DHCP 서버: 실행 중 (PID: $(pgrep -f dhcp-server))"
    # 메모리 사용량 확인
    MEMORY_USAGE=$(ps -p $(pgrep -f dhcp-server) -o rss= | awk '{print $1/1024}')
    echo "   메모리 사용량: ${MEMORY_USAGE}MB"
else
    echo "❌ DHCP 서버: 중지됨"
fi

# 3. 네트워크 포트 확인
echo -e "\n🌐 네트워크 포트 상태:"
if netstat -ulnp | grep :67 > /dev/null; then
    echo "✅ DHCP 서버 포트 (67/UDP): 바인딩됨"
else
    echo "❌ DHCP 서버 포트 (67/UDP): 바인딩 안됨"
fi

# 4. 로그 파일 크기 확인
echo -e "\n📝 로그 파일 상태:"
LOG_DIR="/var/log/dhcp-test"
if [ -d "$LOG_DIR" ]; then
    for log_file in "$LOG_DIR"/*.log; do
        if [ -f "$log_file" ]; then
            SIZE=$(du -h "$log_file" | cut -f1)
            echo "   $(basename "$log_file"): $SIZE"
        fi
    done
else
    echo "   로그 디렉토리 없음: $LOG_DIR"
fi

# 5. 최근 에러 확인
echo -e "\n⚠️ 최근 24시간 에러 (최대 5개):"
if [ -f "/var/log/dhcp-test/server-error.log" ]; then
    tail -n 100 /var/log/dhcp-test/server-error.log | \
    grep "$(date -d '1 day ago' '+%Y-%m-%d')\|$(date '+%Y-%m-%d')" | \
    tail -n 5
else
    echo "   에러 로그 파일 없음"
fi

# 6. 디스크 공간 경고
DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
if [ "$DISK_USAGE" -gt 85 ]; then
    echo -e "\n🚨 경고: 디스크 사용률이 85%를 초과했습니다 ($DISK_USAGE%)"
fi

echo -e "\n=== 일일 점검 완료 ==="
```

#### 주간 점검 스크립트
```bash
#!/bin/bash
# scripts/weekly-check.sh

echo "=== DHCP 테스트 시스템 주간 점검 ==="

# 1. 로그 분석
echo "📊 주간 통계 분석 (최근 7일):"

# 에러 패턴 분석
echo -e "\n에러 발생 빈도:"
grep -h "ERROR\|FAIL\|timeout" /var/log/dhcp-test/*.log 2>/dev/null | \
awk '{print $1}' | sort | uniq -c | sort -nr | head -10

# 성능 트렌드 분석
echo -e "\n성능 트렌드:"
grep "성공률:" /var/log/dhcp-test/tester*.log 2>/dev/null | \
tail -n 20 | awk '{print $1, $NF}' | \
awk '{sum += $2; count++} END {if(count>0) print "평균 성공률:", sum/count "%"}'

# 2. 시스템 헬스 체크
echo -e "\n🏥 시스템 헬스 체크:"
./scripts/health-check.sh

# 3. 보안 점검
echo -e "\n🔐 보안 점검:"
# 로그인 시도 확인
echo "최근 로그인 시도:"
last -n 10 | grep -v "reboot\|wtmp"

# 실행 중인 프로세스 확인
echo -e "\nDHCP 관련 프로세스:"
ps aux | grep -E "dhcp|67|68" | grep -v grep

# 4. 용량 정리 권장사항
echo -e "\n🧹 정리 권장사항:"
find /var/log/dhcp-test -name "*.log" -mtime +30 -exec ls -lh {} \; | \
head -5 | awk '{print "30일 이상 된 로그:", $9, "("$5")"}'

echo -e "\n=== 주간 점검 완료 ==="
```

### 1.2 서비스 관리

#### systemd 서비스 관리
```bash
# 서비스 상태 확인
sudo systemctl status dhcp-test-server

# 서비스 시작/중지/재시작
sudo systemctl start dhcp-test-server
sudo systemctl stop dhcp-test-server
sudo systemctl restart dhcp-test-server

# 서비스 로그 확인
sudo journalctl -u dhcp-test-server -f --since "1 hour ago"

# 설정 리로드
sudo systemctl reload dhcp-test-server

# 부팅 시 자동 시작 설정
sudo systemctl enable dhcp-test-server
```

#### 프로세스 모니터링
```bash
#!/bin/bash
# scripts/process-monitor.sh

PROCESS_NAME="dhcp-server"
MAX_MEMORY_MB=2048  # 2GB
MAX_CPU_PERCENT=80

# 프로세스 찾기
PID=$(pgrep -f "$PROCESS_NAME")

if [ -z "$PID" ]; then
    echo "❌ $PROCESS_NAME 프로세스를 찾을 수 없습니다."
    exit 1
fi

# 리소스 사용량 확인
MEMORY_MB=$(ps -p "$PID" -o rss= | awk '{print int($1/1024)}')
CPU_PERCENT=$(ps -p "$PID" -o %cpu= | awk '{print int($1)}')

echo "📊 $PROCESS_NAME 모니터링 (PID: $PID)"
echo "메모리 사용량: ${MEMORY_MB}MB / ${MAX_MEMORY_MB}MB"
echo "CPU 사용률: ${CPU_PERCENT}% / ${MAX_CPU_PERCENT}%"

# 임계치 확인
if [ "$MEMORY_MB" -gt "$MAX_MEMORY_MB" ]; then
    echo "🚨 메모리 사용량 임계치 초과!"
    # 알림 발송 (선택적)
    # send_alert "Memory threshold exceeded: ${MEMORY_MB}MB"
fi

if [ "$CPU_PERCENT" -gt "$MAX_CPU_PERCENT" ]; then
    echo "🚨 CPU 사용률 임계치 초과!"
    # 알림 발송 (선택적)
    # send_alert "CPU threshold exceeded: ${CPU_PERCENT}%"
fi

# 상세 프로세스 정보
echo -e "\n상세 정보:"
ps -p "$PID" -o pid,ppid,user,%cpu,%mem,etime,cmd
```

### 1.3 로그 관리

#### 로그 로테이션 설정
```bash
# /etc/logrotate.d/dhcp-test
/var/log/dhcp-test/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
    su dhcp-test dhcp-test
    postrotate
        # 로그 로테이션 후 서비스에 시그널 전송 (선택적)
        /bin/kill -HUP $(cat /var/run/dhcp-server.pid 2>/dev/null) 2>/dev/null || true
    endscript
}
```

#### 로그 분석 도구
```bash
#!/bin/bash
# scripts/log-analyzer.sh

LOG_FILE="${1:-/var/log/dhcp-test/server.log}"
TIME_RANGE="${2:-1 hour ago}"

echo "=== DHCP 로그 분석 ==="
echo "파일: $LOG_FILE"
echo "시간 범위: $TIME_RANGE"

if [ ! -f "$LOG_FILE" ]; then
    echo "❌ 로그 파일을 찾을 수 없습니다: $LOG_FILE"
    exit 1
fi

# 1. 기본 통계
echo -e "\n📊 기본 통계:"
TOTAL_LINES=$(wc -l < "$LOG_FILE")
echo "전체 로그 라인 수: $TOTAL_LINES"

# 2. 메시지 타입별 통계
echo -e "\n📈 DHCP 메시지 타입별 통계:"
grep -E "DISCOVER|OFFER|REQUEST|ACK|NAK" "$LOG_FILE" | \
awk '{print $NF}' | sort | uniq -c | sort -nr

# 3. 에러 분석
echo -e "\n❌ 에러 분석:"
grep -i "error\|fail\|timeout" "$LOG_FILE" | \
awk '{print $1, $2, $NF}' | sort | uniq -c | sort -nr | head -10

# 4. 클라이언트 IP 통계
echo -e "\n🌐 클라이언트 IP 분포:"
grep -oE "([0-9]{1,3}\.){3}[0-9]{1,3}" "$LOG_FILE" | \
sort | uniq -c | sort -nr | head -10

# 5. 시간대별 활동
echo -e "\n⏰ 시간대별 활동:"
awk '{print substr($2,1,2)}' "$LOG_FILE" | sort | uniq -c | \
awk '{printf("%s시: %d건\n", $2, $1)}'

# 6. 최근 에러 (상세)
echo -e "\n🔍 최근 에러 (상세):"
grep -i "error\|fail" "$LOG_FILE" | tail -5
```

## 2. 모니터링 및 알림

### 2.1 실시간 모니터링

#### 대시보드 스크립트
```bash
#!/bin/bash
# scripts/dashboard.sh

# 터미널 제어
clear_screen() { printf '\033[2J\033[H'; }
hide_cursor() { printf '\033[?25l'; }
show_cursor() { printf '\033[?25h'; }
color_red() { printf '\033[31m'; }
color_green() { printf '\033[32m'; }
color_yellow() { printf '\033[33m'; }
color_blue() { printf '\033[34m'; }
color_reset() { printf '\033[0m'; }

# 시그널 핸들러
cleanup() {
    show_cursor
    color_reset
    echo -e "\n모니터링 종료됨"
    exit 0
}
trap cleanup SIGINT SIGTERM

# 메인 대시보드
show_dashboard() {
    clear_screen
    hide_cursor
    
    # 헤더
    color_blue
    echo "╔════════════════════════════════════════════════════════════════════════╗"
    echo "║                    DHCP 테스트 시스템 모니터링 대시보드                    ║"
    echo "╚════════════════════════════════════════════════════════════════════════╝"
    color_reset
    
    # 시스템 상태
    echo -e "\n📊 시스템 상태 ($(date '+%Y-%m-%d %H:%M:%S'))"
    echo "----------------------------------------"
    
    # CPU 및 메모리
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    MEMORY_USAGE=$(free | grep Mem | awk '{printf("%.1f", $3/$2 * 100.0)}')
    
    printf "CPU 사용률:    "
    if (( $(echo "$CPU_USAGE > 80" | bc -l) )); then
        color_red; printf "%s%%\n" "$CPU_USAGE"; color_reset
    elif (( $(echo "$CPU_USAGE > 60" | bc -l) )); then
        color_yellow; printf "%s%%\n" "$CPU_USAGE"; color_reset
    else
        color_green; printf "%s%%\n" "$CPU_USAGE"; color_reset
    fi
    
    printf "메모리 사용률: "
    if (( $(echo "$MEMORY_USAGE > 80" | bc -l) )); then
        color_red; printf "%s%%\n" "$MEMORY_USAGE"; color_reset
    else
        color_green; printf "%s%%\n" "$MEMORY_USAGE"; color_reset
    fi
    
    # 프로세스 상태
    echo -e "\n🔧 프로세스 상태"
    echo "----------------------------------------"
    
    if pgrep -f dhcp-server > /dev/null; then
        PID=$(pgrep -f dhcp-server)
        PROC_MEMORY=$(ps -p "$PID" -o rss= | awk '{print int($1/1024)}')
        PROC_CPU=$(ps -p "$PID" -o %cpu= | awk '{print $1}')
        
        color_green
        printf "DHCP 서버:     실행중 (PID: %s)\n" "$PID"
        color_reset
        printf "               메모리: %sMB, CPU: %s%%\n" "$PROC_MEMORY" "$PROC_CPU"
    else
        color_red
        echo "DHCP 서버:     중지됨"
        color_reset
    fi
    
    # 네트워크 상태
    echo -e "\n🌐 네트워크 상태"
    echo "----------------------------------------"
    
    if netstat -ulnp | grep :67 > /dev/null 2>&1; then
        color_green; echo "포트 67/UDP:   바인딩됨"; color_reset
    else
        color_red; echo "포트 67/UDP:   바인딩 안됨"; color_reset
    fi
    
    # 최근 활동
    echo -e "\n📈 최근 활동 (최근 1분)"
    echo "----------------------------------------"
    
    if [ -f "/var/log/dhcp-test/server.log" ]; then
        RECENT_DISCOVER=$(grep "$(date '+%Y-%m-%d %H:%M')" /var/log/dhcp-test/server.log 2>/dev/null | grep -c "DISCOVER" || echo "0")
        RECENT_REQUEST=$(grep "$(date '+%Y-%m-%d %H:%M')" /var/log/dhcp-test/server.log 2>/dev/null | grep -c "REQUEST" || echo "0")
        
        echo "DISCOVER 수신: $RECENT_DISCOVER"
        echo "REQUEST 수신:  $RECENT_REQUEST"
    else
        color_yellow; echo "로그 파일 없음"; color_reset
    fi
    
    # 하단 안내
    echo -e "\n\n"
    color_blue
    echo "[Ctrl+C로 종료]                                    [자동 갱신: 5초]"
    color_reset
}

# 메인 루프
echo "DHCP 테스트 시스템 모니터링 시작..."
while true; do
    show_dashboard
    sleep 5
done
```

### 2.2 알림 시스템

#### 이메일 알림
```bash
#!/bin/bash
# scripts/email-alert.sh

SMTP_SERVER="smtp.gmail.com"
SMTP_PORT="587"
EMAIL_FROM="dhcp-monitor@company.com"
EMAIL_TO="admin@company.com"
EMAIL_SUBJECT="DHCP 테스트 시스템 알림"

send_email_alert() {
    local subject="$1"
    local message="$2"
    local priority="${3:-normal}"  # low, normal, high
    
    # 우선순위에 따른 제목 수정
    case $priority in
        "high")
            subject="🚨 [긴급] $subject"
            ;;
        "low")
            subject="ℹ️ [정보] $subject"
            ;;
        *)
            subject="⚠️ [경고] $subject"
            ;;
    esac
    
    # 메일 내용 생성
    cat << EOF > /tmp/dhcp-alert-mail.txt
From: $EMAIL_FROM
To: $EMAIL_TO
Subject: $subject
Content-Type: text/html; charset=UTF-8

<html>
<body>
<h2>DHCP 테스트 시스템 알림</h2>
<p><strong>시간:</strong> $(date '+%Y-%m-%d %H:%M:%S')</p>
<p><strong>호스트:</strong> $(hostname)</p>
<hr>
<pre>$message</pre>
<hr>
<p><em>이 메일은 자동으로 발송되었습니다.</em></p>
</body>
</html>
EOF
    
    # 메일 발송 (sendmail 사용)
    if command -v sendmail &> /dev/null; then
        sendmail "$EMAIL_TO" < /tmp/dhcp-alert-mail.txt
        echo "이메일 알림 발송됨: $subject"
    else
        echo "sendmail을 찾을 수 없습니다. 이메일 발송 실패."
    fi
    
    # 임시 파일 정리
    rm -f /tmp/dhcp-alert-mail.txt
}

# 사용 예시
# send_email_alert "DHCP 서버 중지됨" "DHCP 서버가 예상치 못하게 중지되었습니다." "high"
```

#### Slack 알림
```bash
#!/bin/bash
# scripts/slack-alert.sh

SLACK_WEBHOOK_URL="https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
SLACK_CHANNEL="#dhcp-alerts"
SLACK_USERNAME="DHCP Monitor"

send_slack_alert() {
    local title="$1"
    local message="$2"
    local color="${3:-warning}"  # good, warning, danger
    
    # 색상 설정
    case $color in
        "good") color="#36a64f" ;;
        "danger") color="#ff0000" ;;
        *) color="#ff9500" ;;
    esac
    
    # Slack 메시지 페이로드 생성
    local payload=$(cat << EOF
{
    "channel": "$SLACK_CHANNEL",
    "username": "$SLACK_USERNAME",
    "attachments": [
        {
            "color": "$color",
            "title": "$title",
            "text": "$message",
            "fields": [
                {
                    "title": "호스트",
                    "value": "$(hostname)",
                    "short": true
                },
                {
                    "title": "시간",
                    "value": "$(date '+%Y-%m-%d %H:%M:%S')",
                    "short": true
                }
            ],
            "footer": "DHCP Monitor",
            "ts": $(date +%s)
        }
    ]
}
EOF
)
    
    # Slack으로 메시지 발송
    if curl -X POST -H 'Content-type: application/json' \
            --data "$payload" \
            "$SLACK_WEBHOOK_URL" \
            --silent --output /dev/null; then
        echo "Slack 알림 발송됨: $title"
    else
        echo "Slack 알림 발송 실패"
    fi
}

# 사용 예시
# send_slack_alert "DHCP 서버 재시작됨" "서버가 정상적으로 재시작되었습니다." "good"
```

### 2.3 임계치 모니터링

#### 임계치 감시 스크립트
```bash
#!/bin/bash
# scripts/threshold-monitor.sh

# 임계치 설정
CPU_THRESHOLD=80
MEMORY_THRESHOLD=85
DISK_THRESHOLD=90
DHCP_ERROR_RATE_THRESHOLD=10  # 10% 이상 에러율

LOG_FILE="/var/log/dhcp-test/threshold-monitor.log"

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

check_system_resources() {
    # CPU 사용률 확인
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1 | cut -d'.' -f1)
    if [ "$CPU_USAGE" -gt "$CPU_THRESHOLD" ]; then
        log_message "⚠️ CPU 사용률 임계치 초과: ${CPU_USAGE}% (임계치: ${CPU_THRESHOLD}%)"
        send_slack_alert "CPU 사용률 경고" "CPU 사용률이 ${CPU_USAGE}%입니다." "warning"
    fi
    
    # 메모리 사용률 확인
    MEMORY_USAGE=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
    if [ "$MEMORY_USAGE" -gt "$MEMORY_THRESHOLD" ]; then
        log_message "⚠️ 메모리 사용률 임계치 초과: ${MEMORY_USAGE}% (임계치: ${MEMORY_THRESHOLD}%)"
        send_slack_alert "메모리 사용률 경고" "메모리 사용률이 ${MEMORY_USAGE}%입니다." "warning"
    fi
    
    # 디스크 사용률 확인
    DISK_USAGE=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
    if [ "$DISK_USAGE" -gt "$DISK_THRESHOLD" ]; then
        log_message "🚨 디스크 사용률 임계치 초과: ${DISK_USAGE}% (임계치: ${DISK_THRESHOLD}%)"
        send_slack_alert "디스크 공간 경고" "디스크 사용률이 ${DISK_USAGE}%입니다." "danger"
    fi
}

check_dhcp_performance() {
    local dhcp_log="/var/log/dhcp-test/server.log"
    
    if [ -f "$dhcp_log" ]; then
        # 최근 10분간의 에러율 확인
        local current_time=$(date '+%Y-%m-%d %H:%M')
        local ten_min_ago=$(date -d '10 minutes ago' '+%Y-%m-%d %H:%M')
        
        local total_requests=$(grep -E "${ten_min_ago}|${current_time}" "$dhcp_log" | grep -c "DISCOVER\|REQUEST" || echo "0")
        local error_count=$(grep -E "${ten_min_ago}|${current_time}" "$dhcp_log" | grep -c "ERROR\|FAIL\|timeout" || echo "0")
        
        if [ "$total_requests" -gt 0 ]; then
            local error_rate=$((error_count * 100 / total_requests))
            
            if [ "$error_rate" -gt "$DHCP_ERROR_RATE_THRESHOLD" ]; then
                log_message "⚠️ DHCP 에러율 임계치 초과: ${error_rate}% (${error_count}/${total_requests})"
                send_slack_alert "DHCP 에러율 경고" "최근 10분간 에러율이 ${error_rate}%입니다." "warning"
            fi
        fi
    fi
}

check_process_health() {
    if ! pgrep -f dhcp-server > /dev/null; then
        log_message "🚨 DHCP 서버 프로세스가 실행되지 않고 있습니다!"
        send_slack_alert "DHCP 서버 중지" "DHCP 서버 프로세스를 찾을 수 없습니다." "danger"
        
        # 자동 재시작 시도 (선택적)
        if [ "${AUTO_RESTART:-false}" = "true" ]; then
            log_message "자동 재시작 시도 중..."
            systemctl start dhcp-test-server
            sleep 5
            
            if pgrep -f dhcp-server > /dev/null; then
                log_message "✅ DHCP 서버 자동 재시작 성공"
                send_slack_alert "DHCP 서버 재시작" "서버가 자동으로 재시작되었습니다." "good"
            else
                log_message "❌ DHCP 서버 자동 재시작 실패"
                send_slack_alert "DHCP 서버 재시작 실패" "자동 재시작에 실패했습니다. 수동 확인이 필요합니다." "danger"
            fi
        fi
    fi
}

# 메인 모니터링 루프
main() {
    log_message "=== 임계치 모니터링 시작 ==="
    
    while true; do
        check_system_resources
        check_dhcp_performance
        check_process_health
        
        sleep 60  # 1분마다 확인
    done
}

# 시그널 핸들러
cleanup() {
    log_message "=== 임계치 모니터링 종료 ==="
    exit 0
}
trap cleanup SIGINT SIGTERM

# 실행
main "$@"
```

## 3. 트러블슈팅

### 3.1 일반적인 문제 해결

#### 연결 관련 문제
```bash
#!/bin/bash
# scripts/troubleshoot-connection.sh

echo "=== DHCP 연결 문제 진단 ==="

# 1. 네트워크 인터페이스 확인
echo "🔍 네트워크 인터페이스 상태:"
ip addr show | grep -E "^[0-9]|inet "

# 2. 포트 바인딩 확인
echo -e "\n🔍 포트 바인딩 상태:"
echo "DHCP 서버 포트 (67/UDP):"
netstat -ulnp | grep :67 || echo "  바인딩되지 않음"

echo "DHCP 클라이언트 포트 (68/UDP):"
netstat -ulnp | grep :68 || echo "  바인딩되지 않음"

# 3. 방화벽 확인
echo -e "\n🔍 방화벽 상태:"
if command -v ufw &> /dev/null; then
    ufw status | grep -E "67|68"
elif command -v firewall-cmd &> /dev/null; then
    firewall-cmd --list-ports | grep -E "67|68"
else
    echo "  방화벽 도구를 찾을 수 없음"
fi

# 4. 프로세스 확인
echo -e "\n🔍 관련 프로세스:"
ps aux | grep -E "dhcp|67|68" | grep -v grep

# 5. 권한 확인
echo -e "\n🔍 권한 확인:"
echo "현재 사용자: $(whoami)"
if [ "$(id -u)" -eq 0 ]; then
    echo "  ✅ Root 권한"
else
    echo "  ⚠️ 일반 사용자 권한"
    echo "  포트 67/68 바인딩을 위해 sudo 권한이 필요할 수 있습니다."
fi

# 6. 포트 연결성 테스트
echo -e "\n🔍 포트 연결성 테스트:"
test_port() {
    local host="$1"
    local port="$2"
    local protocol="$3"
    
    if command -v nc &> /dev/null; then
        if [ "$protocol" = "udp" ]; then
            timeout 3 nc -u -z "$host" "$port" 2>/dev/null
        else
            timeout 3 nc -z "$host" "$port" 2>/dev/null
        fi
        
        if [ $? -eq 0 ]; then
            echo "  ✅ $host:$port ($protocol) - 연결 가능"
        else
            echo "  ❌ $host:$port ($protocol) - 연결 불가"
        fi
    else
        echo "  nc 명령어를 찾을 수 없음"
    fi
}

test_port "127.0.0.1" "67" "udp"
test_port "localhost" "67" "udp"

# 7. 로그 확인
echo -e "\n🔍 최근 에러 로그:"
if [ -f "/var/log/dhcp-test/server-error.log" ]; then
    tail -5 /var/log/dhcp-test/server-error.log
else
    echo "  에러 로그 파일을 찾을 수 없음"
fi

echo -e "\n=== 진단 완료 ==="
```

#### 성능 관련 문제
```bash
#!/bin/bash
# scripts/troubleshoot-performance.sh

echo "=== DHCP 성능 문제 진단 ==="

# 1. 시스템 리소스 확인
echo "🔍 시스템 리소스 사용률:"
echo "CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')"
echo "메모리: $(free -h | grep Mem | awk '{print $3 "/" $2}')"
echo "디스크 I/O:"
iostat -x 1 1 2>/dev/null | tail -n +4 | head -5 || echo "  iostat를 사용할 수 없음"

# 2. 네트워크 트래픽 확인
echo -e "\n🔍 네트워크 트래픽:"
if command -v iftop &> /dev/null; then
    echo "  iftop이 설치되어 있습니다. 'sudo iftop -i any -P' 로 실시간 확인 가능"
else
    echo "  네트워크 통계 (인터페이스별):"
    cat /proc/net/dev | grep -E "eth|ens|wlan" | head -3
fi

# 3. 프로세스별 리소스 사용량
echo -e "\n🔍 DHCP 관련 프로세스 리소스 사용량:"
ps aux | grep -E "dhcp" | grep -v grep | awk '{printf("PID: %s, CPU: %s%%, MEM: %s%%, CMD: %s\n", $2, $3, $4, $11)}'

# 4. 메모리 누수 확인
echo -e "\n🔍 메모리 사용 패턴 (5초 간격으로 3회 측정):"
for i in {1..3}; do
    DHCP_PID=$(pgrep -f dhcp-server)
    if [ -n "$DHCP_PID" ]; then
        MEMORY_KB=$(ps -p "$DHCP_PID" -o rss= 2>/dev/null || echo "0")
        MEMORY_MB=$((MEMORY_KB / 1024))
        echo "  측정 $i: ${MEMORY_MB}MB"
    else
        echo "  측정 $i: 프로세스 없음"
    fi
    [ $i -lt 3 ] && sleep 5
done

# 5. 파일 디스크립터 사용량
echo -e "\n🔍 파일 디스크립터 사용량:"
DHCP_PID=$(pgrep -f dhcp-server)
if [ -n "$DHCP_PID" ]; then
    FD_COUNT=$(ls -1 /proc/"$DHCP_PID"/fd 2>/dev/null | wc -l || echo "0")
    FD_LIMIT=$(cat /proc/"$DHCP_PID"/limits 2>/dev/null | grep "Max open files" | awk '{print $4}' || echo "unknown")
    echo "  사용 중: $FD_COUNT"
    echo "  제한: $FD_LIMIT"
    
    if [ "$FD_COUNT" -gt 1000 ]; then
        echo "  ⚠️ 파일 디스크립터 사용량이 높습니다."
    fi
else
    echo "  DHCP 프로세스를 찾을 수 없음"
fi

# 6. 네트워크 버퍼 확인
echo -e "\n🔍 네트워크 버퍼 크기:"
echo "수신 버퍼: $(cat /proc/sys/net/core/rmem_default) / $(cat /proc/sys/net/core/rmem_max)"
echo "송신 버퍼: $(cat /proc/sys/net/core/wmem_default) / $(cat /proc/sys/net/core/wmem_max)"

# 7. 최근 성능 통계
echo -e "\n🔍 최근 성능 통계 (로그 기반):"
if [ -f "/var/log/dhcp-test/tester.log" ]; then
    echo "최근 테스트 결과:"
    grep -E "성공률|평균.*시간|초당.*수" /var/log/dhcp-test/tester.log | tail -5
else
    echo "  성능 로그를 찾을 수 없음"
fi

echo -e "\n=== 성능 진단 완료 ==="
```

### 3.2 자주 발생하는 문제와 해결책

#### 문제 1: "Permission denied" 에러
```bash
# 문제 진단
echo "=== Permission denied 문제 해결 ==="

# 1. 현재 권한 확인
echo "현재 사용자: $(whoami)"
echo "UID: $(id -u)"

# 2. 포트 67/68은 일반적으로 관리자 권한 필요
if [ "$(id -u)" -ne 0 ]; then
    echo "해결방안:"
    echo "1. sudo로 실행: sudo ./dhcp-server"
    echo "2. 다른 포트 사용: ./dhcp-server -port 6700"
    echo "3. 권한 없이 테스트: ./dhcp-tester -skip-priv-check"
fi

# 3. 파일 권한 확인
echo -e "\n파일 권한 확인:"
ls -l dhcp-server dhcp-tester 2>/dev/null || echo "바이너리 파일을 찾을 수 없음"
```

#### 문제 2: "Address already in use" 에러
```bash
# 문제 진단 및 해결
echo "=== 포트 사용 중 문제 해결 ==="

# 1. 포트 67을 사용하는 프로세스 찾기
echo "포트 67을 사용하는 프로세스:"
sudo lsof -i :67 2>/dev/null || netstat -ulnp | grep :67

# 2. DHCP 서비스 확인
echo -e "\n시스템 DHCP 서비스 상태:"
systemctl is-active dhcpd 2>/dev/null || echo "dhcpd 서비스 없음"
systemctl is-active isc-dhcp-server 2>/dev/null || echo "isc-dhcp-server 서비스 없음"

# 3. 해결 방안 제시
echo -e "\n해결 방안:"
echo "1. 기존 프로세스 종료: sudo kill \$(lsof -t -i:67)"
echo "2. 다른 포트 사용: ./dhcp-server -port 6700"
echo "3. 시스템 DHCP 서비스 중지: sudo systemctl stop dhcpd"
```

#### 문제 3: 높은 메모리 사용량
```bash
# 메모리 사용량 최적화
echo "=== 메모리 사용량 최적화 ==="

DHCP_PID=$(pgrep -f dhcp-server)
if [ -n "$DHCP_PID" ]; then
    MEMORY_MB=$(ps -p "$DHCP_PID" -o rss= | awk '{print int($1/1024)}')
    echo "현재 메모리 사용량: ${MEMORY_MB}MB"
    
    if [ "$MEMORY_MB" -gt 1024 ]; then
        echo "⚠️ 높은 메모리 사용량 감지"
        echo "권장 조치:"
        echo "1. 동시 클라이언트 수 제한: -concurrency 50"
        echo "2. IP 풀 크기 조정"
        echo "3. 세션 타임아웃 단축: -offer-timeout 10s"
        echo "4. 서비스 재시작 고려"
    fi
else
    echo "DHCP 프로세스를 찾을 수 없음"
fi
```

### 3.3 고급 디버깅

#### 네트워크 패킷 캡처
```bash
#!/bin/bash
# scripts/packet-capture.sh

INTERFACE="${1:-any}"
DURATION="${2:-60}"
OUTPUT_FILE="dhcp-capture-$(date +%Y%m%d_%H%M%S).pcap"

echo "=== DHCP 패킷 캡처 시작 ==="
echo "인터페이스: $INTERFACE"
echo "캡처 시간: ${DURATION}초"
echo "출력 파일: $OUTPUT_FILE"

# tcpdump를 사용한 패킷 캡처
sudo tcpdump -i "$INTERFACE" -w "$OUTPUT_FILE" -s 0 \
    "port 67 or port 68" &
TCPDUMP_PID=$!

echo "패킷 캡처 중... (PID: $TCPDUMP_PID)"
echo "중단하려면 Ctrl+C를 누르세요."

# 지정된 시간 후 자동 종료
sleep "$DURATION"
sudo kill "$TCPDUMP_PID" 2>/dev/null

echo "패킷 캡처 완료: $OUTPUT_FILE"
echo "분석을 위해 다음 명령어를 사용하세요:"
echo "  tcpdump -r $OUTPUT_FILE"
echo "  wireshark $OUTPUT_FILE"

# 간단한 통계 출력
if [ -f "$OUTPUT_FILE" ]; then
    PACKET_COUNT=$(tcpdump -r "$OUTPUT_FILE" 2>/dev/null | wc -l)
    echo "캡처된 패킷 수: $PACKET_COUNT"
fi
```

#### 상세 로그 분석
```bash
#!/bin/bash
# scripts/detailed-log-analysis.sh

LOG_FILE="${1:-/var/log/dhcp-test/server.log}"
OUTPUT_DIR="log-analysis-$(date +%Y%m%d_%H%M%S)"

echo "=== 상세 로그 분석 ==="
echo "로그 파일: $LOG_FILE"
echo "출력 디렉토리: $OUTPUT_DIR"

mkdir -p "$OUTPUT_DIR"

# 1. 기본 통계
echo "📊 기본 통계 생성 중..."
{
    echo "=== DHCP 로그 분석 보고서 ==="
    echo "분석 시간: $(date)"
    echo "로그 파일: $LOG_FILE"
    echo ""
    
    echo "1. 전체 통계"
    echo "총 로그 라인 수: $(wc -l < "$LOG_FILE")"
    echo "분석 기간: $(head -1 "$LOG_FILE" | awk '{print $1, $2}') ~ $(tail -1 "$LOG_FILE" | awk '{print $1, $2}')"
    echo ""
    
    echo "2. 메시지 타입별 통계"
    grep -oE "(DISCOVER|OFFER|REQUEST|ACK|NAK)" "$LOG_FILE" | sort | uniq -c | sort -nr
    echo ""
    
    echo "3. 에러 통계"
    grep -i "error\|fail\|timeout" "$LOG_FILE" | awk '{print $NF}' | sort | uniq -c | sort -nr
    echo ""
    
    echo "4. 시간대별 활동"
    awk '{print substr($2,1,2)}' "$LOG_FILE" | sort | uniq -c | sort -k2n
    
} > "$OUTPUT_DIR/basic-stats.txt"

# 2. 에러 상세 분석
echo "❌ 에러 상세 분석 중..."
grep -i "error\|fail\|timeout" "$LOG_FILE" > "$OUTPUT_DIR/errors.log"

# 3. 클라이언트 IP 분포
echo "🌐 클라이언트 분석 중..."
grep -oE "([0-9]{1,3}\.){3}[0-9]{1,3}" "$LOG_FILE" | sort | uniq -c | sort -nr > "$OUTPUT_DIR/client-ips.txt"

# 4. 시간별 트래픽 분석
echo "📈 시간별 트래픽 분석 중..."
awk '{print $1 " " substr($2,1,5)}' "$LOG_FILE" | sort | uniq -c > "$OUTPUT_DIR/traffic-by-time.txt"

# 5. 성능 메트릭 추출
echo "⚡ 성능 메트릭 추출 중..."
{
    echo "=== 성능 메트릭 ==="
    echo ""
    
    echo "처리 시간 분포:"
    grep -oE "처리시간: [0-9.]+[a-z]+" "$LOG_FILE" | sort | uniq -c
    echo ""
    
    echo "응답 시간 분포:"
    grep -oE "응답시간: [0-9.]+[a-z]+" "$LOG_FILE" | sort | uniq -c
    
} > "$OUTPUT_DIR/performance-metrics.txt"

# 6. 보안 관련 이벤트
echo "🔒 보안 이벤트 분석 중..."
grep -iE "unauthorized|invalid|malformed|attack" "$LOG_FILE" > "$OUTPUT_DIR/security-events.log"

# 7. 요약 보고서 생성
echo "📋 요약 보고서 생성 중..."
{
    echo "=== 로그 분석 요약 ==="
    echo ""
    
    echo "🔍 주요 발견사항:"
    
    # 에러율 계산
    TOTAL_REQUESTS=$(grep -cE "(DISCOVER|REQUEST)" "$LOG_FILE")
    ERROR_COUNT=$(grep -ciE "error|fail|timeout" "$LOG_FILE")
    if [ "$TOTAL_REQUESTS" -gt 0 ]; then
        ERROR_RATE=$((ERROR_COUNT * 100 / TOTAL_REQUESTS))
        echo "- 전체 에러율: ${ERROR_RATE}% (${ERROR_COUNT}/${TOTAL_REQUESTS})"
    fi
    
    # 가장 많은 에러 유형
    TOP_ERROR=$(grep -i "error\|fail\|timeout" "$LOG_FILE" | awk '{print $NF}' | sort | uniq -c | sort -nr | head -1)
    echo "- 주요 에러 유형: $TOP_ERROR"
    
    # 피크 시간대
    PEAK_HOUR=$(awk '{print substr($2,1,2)}' "$LOG_FILE" | sort | uniq -c | sort -nr | head -1 | awk '{print $2}')
    echo "- 피크 시간대: ${PEAK_HOUR}시"
    
    echo ""
    echo "📁 상세 분석 파일:"
    echo "- 기본 통계: basic-stats.txt"
    echo "- 에러 로그: errors.log"
    echo "- 클라이언트 IP: client-ips.txt"
    echo "- 시간별 트래픽: traffic-by-time.txt"
    echo "- 성능 메트릭: performance-metrics.txt"
    echo "- 보안 이벤트: security-events.log"
    
} > "$OUTPUT_DIR/summary.txt"

echo "✅ 로그 분석 완료"
echo "결과 확인: cat $OUTPUT_DIR/summary.txt"
```

## 4. 성능 최적화

### 4.1 시스템 튜닝

#### 네트워크 최적화
```bash
#!/bin/bash
# scripts/network-optimization.sh

echo "=== 네트워크 성능 최적화 ==="

# 현재 설정 백업
cp /etc/sysctl.conf /etc/sysctl.conf.backup.$(date +%Y%m%d)

# 네트워크 버퍼 크기 최적화
cat >> /etc/sysctl.conf << EOF

# DHCP 성능 최적화 설정
# 네트워크 버퍼 크기 증가
net.core.rmem_default = 262144
net.core.rmem_max = 16777216
net.core.wmem_default = 262144
net.core.wmem_max = 16777216

# UDP 버퍼 크기 증가
net.core.netdev_max_backlog = 5000
net.core.netdev_budget = 300

# 소켓 연결 수 증가
net.core.somaxconn = 65536

# TIME_WAIT 소켓 재사용
net.ipv4.tcp_tw_reuse = 1

# 파일 디스크립터 수 증가
fs.file-max = 65536
EOF

# 설정 적용
sysctl -p

echo "네트워크 최적화 적용 완료"
```

#### 프로세스 최적화
```bash
#!/bin/bash
# scripts/process-optimization.sh

echo "=== 프로세스 최적화 ==="

# 1. ulimit 설정 최적화
echo "현재 ulimit 설정:"
ulimit -a

# 2. systemd 서비스 최적화
cat > /etc/systemd/system/dhcp-test-optimized.service << EOF
[Unit]
Description=DHCP Test Server (Optimized)
After=network.target

[Service]
Type=simple
User=dhcp-test
Group=dhcp-test
WorkingDirectory=/opt/dhcp-test

# 실행 명령어
ExecStart=/opt/dhcp-test/dhcp-server \\
  -listen 0.0.0.0 \\
  -port 67 \\
  -start-ip 192.168.100.10 \\
  -end-ip 192.168.100.250 \\
  -max-concurrent 5000 \\
  -response-delay 0ms

# 성능 최적화
LimitNOFILE=65536
LimitNPROC=8192
LimitMEMLOCK=infinity

# CPU 친화성 설정 (멀티코어 활용)
CPUAffinity=0-3

# 메모리 최적화
MemoryHigh=4G
MemoryMax=8G

# I/O 우선순위
IOSchedulingClass=1
IOSchedulingPriority=4

# 재시작 정책
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
echo "최적화된 서비스 설정 완료"
```

### 4.2 애플리케이션 튜닝

#### Go 런타임 최적화
```bash
#!/bin/bash
# scripts/go-runtime-optimization.sh

echo "=== Go 런타임 최적화 ==="

# 환경 변수 설정
cat > /etc/environment << EOF
# Go 런타임 최적화
GOMAXPROCS=8
GOGC=100
GODEBUG=gctrace=0

# 메모리 할당 최적화
GOMEMLIMIT=4GiB
EOF

# systemd 서비스용 환경 변수
mkdir -p /etc/systemd/system/dhcp-test-server.service.d
cat > /etc/systemd/system/dhcp-test-server.service.d/optimization.conf << EOF
[Service]
Environment="GOMAXPROCS=8"
Environment="GOGC=100"
Environment="GOMEMLIMIT=4GiB"
EOF

systemctl daemon-reload
echo "Go 런타임 최적화 완료"
```

#### 빌드 최적화
```bash
#!/bin/bash
# scripts/optimized-build.sh

echo "=== 최적화 빌드 ==="

# 성능 최적화 빌드
echo "성능 최적화 빌드 중..."
go build -ldflags="-s -w" \
         -gcflags="-N -l" \
         -tags=netgo \
         -a \
         -o dhcp-tester-optimized \
         dhcp-tester.go

go build -ldflags="-s -w" \
         -gcflags="-N -l" \
         -tags=netgo \
         -a \
         -o dhcp-server-optimized \
         dhcp-server.go

# 프로파일 기반 최적화 (PGO)
echo "프로파일 데이터 수집 중..."
./dhcp-server-optimized -live &
SERVER_PID=$!
sleep 5

# 프로파일 수집을 위한 테스트 실행
./dhcp-tester-optimized -server 127.0.0.1 -clients 1000 -concurrency 100

# 프로파일 데이터로 재빌드
kill $SERVER_PID
echo "PGO 기반 재빌드..."

# CPU 프로파일 수집 후 빌드 (실제로는 pprof 데이터 필요)
go build -ldflags="-s -w" \
         -pgo=auto \
         -o dhcp-tester-pgo \
         dhcp-tester.go

echo "최적화 빌드 완료"
ls -lh dhcp-*-optimized dhcp-*-pgo
```

## 5. 보안 운영

### 5.1 접근 제어

#### 방화벽 규칙
```bash
#!/bin/bash
# scripts/firewall-setup.sh

echo "=== 방화벽 보안 설정 ==="

# Ubuntu/Debian UFW 설정
if command -v ufw &> /dev/null; then
    echo "UFW 방화벽 설정 중..."
    
    # 기본 정책 설정
    ufw --force reset
    ufw default deny incoming
    ufw default allow outgoing
    
    # SSH 접근 허용 (관리용)
    ufw allow ssh
    
    # DHCP 포트 허용 (특정 네트워크만)
    ufw allow from 192.168.0.0/16 to any port 67 proto udp
    ufw allow from 192.168.0.0/16 to any port 68 proto udp
    ufw allow from 10.0.0.0/8 to any port 67 proto udp
    ufw allow from 10.0.0.0/8 to any port 68 proto udp
    
    # 모니터링 포트 (로컬만)
    ufw allow from 127.0.0.1 to any port 8080 proto tcp
    
    ufw --force enable
    echo "UFW 설정 완료"

# CentOS/RHEL firewalld 설정
elif command -v firewall-cmd &> /dev/null; then
    echo "firewalld 설정 중..."
    
    # DHCP 서비스 허용
    firewall-cmd --permanent --add-service=dhcp
    
    # 특정 소스에서만 접근 허용
    firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.0.0/16" service name="dhcp" accept'
    firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="10.0.0.0/8" service name="dhcp" accept'
    
    firewall-cmd --reload
    echo "firewalld 설정 완료"

else
    echo "지원되는 방화벽 도구를 찾을 수 없습니다."
fi

# 현재 방화벽 상태 표시
echo -e "\n현재 방화벽 규칙:"
if command -v ufw &> /dev/null; then
    ufw status numbered
elif command -v firewall-cmd &> /dev/null; then
    firewall-cmd --list-all
fi
```

### 5.2 보안 모니터링

#### 침입 탐지
```bash
#!/bin/bash
# scripts/intrusion-detection.sh

LOG_FILE="/var/log/dhcp-test/security.log"
ALERT_FILE="/var/log/dhcp-test/security-alerts.log"

log_security_event() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

check_suspicious_activity() {
    local dhcp_log="/var/log/dhcp-test/server.log"
    
    if [ ! -f "$dhcp_log" ]; then
        return
    fi
    
    # 1. 비정상적인 요청 빈도 확인
    log_security_event "=== 보안 검사 시작 ==="
    
    # 최근 5분간 동일 클라이언트의 과도한 요청
    local recent_time=$(date -d '5 minutes ago' '+%Y-%m-%d %H:%M')
    local suspicious_clients=$(
        grep "$recent_time" "$dhcp_log" | \
        grep -oE "([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}" | \
        sort | uniq -c | awk '$1 > 100 {print $2, $1}'
    )
    
    if [ -n "$suspicious_clients" ]; then
        log_security_event "⚠️ 의심스러운 클라이언트 활동 감지:"
        echo "$suspicious_clients" | while read mac count; do
            log_security_event "  MAC: $mac, 요청 수: $count"
        done
    fi
    
    # 2. 비정상적인 DHCP 옵션 확인
    local malformed_packets=$(grep -c "malformed\|invalid option\|parsing error" "$dhcp_log" || echo "0")
    if [ "$malformed_packets" -gt 10 ]; then
        log_security_event "⚠️ 비정상 패킷 감지: $malformed_packets 개"
    fi
    
    # 3. IP 고갈 공격 탐지
    local pool_exhaustion=$(grep -c "IP 풀 고갈\|pool exhausted" "$dhcp_log" || echo "0")
    if [ "$pool_exhaustion" -gt 5 ]; then
        log_security_event "🚨 IP 풀 고갈 공격 의심: $pool_exhaustion 회"
        echo "[$(date)] IP Pool Exhaustion Attack Detected" >> "$ALERT_FILE"
    fi
    
    log_security_event "=== 보안 검사 완료 ==="
}

# 지속적인 모니터링
monitor_security() {
    echo "보안 모니터링 시작..."
    
    while true; do
        check_suspicious_activity
        sleep 300  # 5분마다 확인
    done
}

# 메인 실행
case "${1:-monitor}" in
    "check")
        check_suspicious_activity
        ;;
    "monitor")
        monitor_security
        ;;
    *)
        echo "사용법: $0 [check|monitor]"
        exit 1
        ;;
esac
```

### 5.3 감사 로그

#### 보안 감사 스크립트
```bash
#!/bin/bash
# scripts/security-audit.sh

AUDIT_DIR="/var/log/dhcp-test/audit"
AUDIT_FILE="$AUDIT_DIR/security-audit-$(date +%Y%m%d).log"

mkdir -p "$AUDIT_DIR"

audit_log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$AUDIT_FILE"
}

security_audit() {
    audit_log "=== DHCP 시스템 보안 감사 시작 ==="
    
    # 1. 파일 권한 검사
    audit_log "📁 파일 권한 검사:"
    
    local critical_files=(
        "/opt/dhcp-test/dhcp-server"
        "/opt/dhcp-test/dhcp-tester"
        "/etc/systemd/system/dhcp-test-server.service"
        "/etc/dhcp-test/production.conf"
    )
    
    for file in "${critical_files[@]}"; do
        if [ -f "$file" ]; then
            local perms=$(ls -l "$file" | awk '{print $1, $3, $4}')
            audit_log "  $file: $perms"
            
            # 권한 검증
            if [[ "$file" == *".conf" ]] && [[ "$(ls -l "$file" | cut -c5-7)" != "---" ]]; then
                audit_log "  ⚠️ 설정 파일에 그룹 읽기 권한이 있습니다: $file"
            fi
        else
            audit_log "  ❌ 파일을 찾을 수 없음: $file"
        fi
    done
    
    # 2. 프로세스 검사
    audit_log "🔍 프로세스 검사:"
    local dhcp_processes=$(ps aux | grep -E "dhcp" | grep -v grep)
    if [ -n "$dhcp_processes" ]; then
        audit_log "  실행 중인 DHCP 프로세스:"
        echo "$dhcp_processes" | while read line; do
            audit_log "    $line"
        done
    else
        audit_log "  실행 중인 DHCP 프로세스 없음"
    fi
    
    # 3. 네트워크 연결 검사
    audit_log "🌐 네트워크 연결 검사:"
    local network_connections=$(netstat -tulpn | grep -E ":67|:68")
    if [ -n "$network_connections" ]; then
        audit_log "  DHCP 관련 네트워크 연결:"
        echo "$network_connections" | while read line; do
            audit_log "    $line"
        done
    fi
    
    # 4. 로그 파일 무결성 검사
    audit_log "📝 로그 파일 무결성 검사:"
    local log_files=(
        "/var/log/dhcp-test/server.log"
        "/var/log/dhcp-test/server-error.log"
        "/var/log/dhcp-test/security.log"
    )
    
    for log_file in "${log_files[@]}"; do
        if [ -f "$log_file" ]; then
            local size=$(du -h "$log_file" | cut -f1)
            local last_modified=$(stat -c %y "$log_file" | cut -d. -f1)
            audit_log "  $log_file: 크기=$size, 수정=$last_modified"
        fi
    done
    
    # 5. 시스템 보안 설정 검사
    audit_log "🔒 시스템 보안 설정:"
    
    # 방화벽 상태
    if command -v ufw &> /dev/null; then
        local ufw_status=$(ufw status | head -1)
        audit_log "  UFW 상태: $ufw_status"
    elif command -v firewall-cmd &> /dev/null; then
        local firewall_status=$(firewall-cmd --state)
        audit_log "  firewalld 상태: $firewall_status"
    fi
    
    # SELinux 상태 (해당되는 경우)
    if command -v getenforce &> /dev/null; then
        local selinux_status=$(getenforce)
        audit_log "  SELinux 상태: $selinux_status"
    fi
    
    # 6. 최근 보안 이벤트 요약
    audit_log "📊 최근 보안 이벤트 요약 (24시간):"
    if [ -f "/var/log/dhcp-test/security.log" ]; then
        local security_events=$(grep "$(date -d '1 day ago' '+%Y-%m-%d')\|$(date '+%Y-%m-%d')" \
                               /var/log/dhcp-test/security.log | wc -l)
        audit_log "  보안 이벤트 수: $security_events"
        
        local alerts=$(grep "🚨\|ALERT" /var/log/dhcp-test/security.log | \
                      grep "$(date -d '1 day ago' '+%Y-%m-%d')\|$(date '+%Y-%m-%d')" | wc -l)
        audit_log "  심각한 알림 수: $alerts"
    else
        audit_log "  보안 로그 파일 없음"
    fi
    
    audit_log "=== 보안 감사 완료 ==="
}

# 메인 실행
security_audit

echo "보안 감사 완료. 결과: $AUDIT_FILE"
```

## 6. 백업 및 복구

### 6.1 백업 전략

#### 자동 백업 스크립트
```bash
#!/bin/bash
# scripts/backup.sh

BACKUP_DIR="/var/backups/dhcp-test"
RETENTION_DAYS=30
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p "$BACKUP_DIR"

backup_logs() {
    echo "=== 로그 백업 ==="
    
    local log_backup_dir="$BACKUP_DIR/logs/$DATE"
    mkdir -p "$log_backup_dir"
    
    # 로그 파일 압축 백업
    if [ -d "/var/log/dhcp-test" ]; then
        tar -czf "$log_backup_dir/dhcp-logs-$DATE.tar.gz" \
            -C /var/log dhcp-test/
        echo "로그 백업 완료: $log_backup_dir/dhcp-logs-$DATE.tar.gz"
    fi
}

backup_config() {
    echo "=== 설정 백업 ==="
    
    local config_backup_dir="$BACKUP_DIR/config/$DATE"
    mkdir -p "$config_backup_dir"
    
    # 시스템 설정 파일
    local config_files=(
        "/etc/systemd/system/dhcp-test-server.service"
        "/etc/dhcp-test/"
        "/etc/logrotate.d/dhcp-test"
    )
    
    for config in "${config_files[@]}"; do
        if [ -e "$config" ]; then
            cp -r "$config" "$config_backup_dir/"
            echo "설정 백업: $config"
        fi
    done
    
    # 설정 압축
    tar -czf "$config_backup_dir/../config-$DATE.tar.gz" \
        -C "$config_backup_dir" .
    rm -rf "$config_backup_dir"
}

backup_binaries() {
    echo "=== 바이너리 백업 ==="
    
    local binary_backup_dir="$BACKUP_DIR/binaries/$DATE"
    mkdir -p "$binary_backup_dir"
    
    # 실행 파일 백업
    if [ -d "/opt/dhcp-test" ]; then
        cp -r /opt/dhcp-test/* "$binary_backup_dir/"
        
        # 압축
        tar -czf "$binary_backup_dir/../binaries-$DATE.tar.gz" \
            -C "$binary_backup_dir" .
        rm -rf "$binary_backup_dir"
        echo "바이너리 백업 완료"
    fi
}

cleanup_old_backups() {
    echo "=== 오래된 백업 정리 ==="
    
    # 30일 이전 백업 삭제
    find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete
    find "$BACKUP_DIR" -type d -empty -delete
    
    echo "오래된 백업 정리 완료"
}

# 메인 백업 실행
main_backup() {
    echo "DHCP 테스트 시스템 백업 시작: $DATE"
    
    backup_logs
    backup_config
    backup_binaries
    cleanup_old_backups
    
    # 백업 완료 알림
    local backup_size=$(du -sh "$BACKUP_DIR" | cut -f1)
    echo "백업 완료: 총 크기 $backup_size"
    
    # 백업 인덱스 업데이트
    echo "$DATE,logs,config,binaries" >> "$BACKUP_DIR/backup-index.csv"
}

main_backup
```

### 6.2 복구 절차

#### 복구 스크립트
```bash
#!/bin/bash
# scripts/restore.sh

BACKUP_DIR="/var/backups/dhcp-test"
RESTORE_DATE="$1"

if [ -z "$RESTORE_DATE" ]; then
    echo "사용법: $0 <YYYYMMDD_HHMMSS>"
    echo ""
    echo "사용 가능한 백업:"
    ls -la "$BACKUP_DIR"/*/*.tar.gz | awk '{print $9}' | sort
    exit 1
fi

restore_config() {
    echo "=== 설정 복구 ==="
    
    local config_file="$BACKUP_DIR/config/config-$RESTORE_DATE.tar.gz"
    
    if [ -f "$config_file" ]; then
        # 현재 설정 백업
        cp -r /etc/systemd/system/dhcp-test-server.service \
              /tmp/dhcp-config-backup-$(date +%s) 2>/dev/null || true
        
        # 설정 복구
        tar -xzf "$config_file" -C /tmp/
        cp -r /tmp/dhcp-test-server.service /etc/systemd/system/ 2>/dev/null || true
        cp -r /tmp/dhcp-test/ /etc/ 2>/dev/null || true
        
        systemctl daemon-reload
        echo "설정 복구 완료"
    else
        echo "설정 백업 파일을 찾을 수 없음: $config_file"
    fi
}

restore_binaries() {
    echo "=== 바이너리 복구 ==="
    
    local binary_file="$BACKUP_DIR/binaries/binaries-$RESTORE_DATE.tar.gz"
    
    if [ -f "$binary_file" ]; then
        # 서비스 중지
        systemctl stop dhcp-test-server 2>/dev/null || true
        
        # 현재 바이너리 백업
        if [ -d "/opt/dhcp-test" ]; then
            mv /opt/dhcp-test "/opt/dhcp-test-backup-$(date +%s)"
        fi
        
        # 바이너리 복구
        mkdir -p /opt/dhcp-test
        tar -xzf "$binary_file" -C /opt/dhcp-test/
        chown -R dhcp-test:dhcp-test /opt/dhcp-test
        chmod +x /opt/dhcp-test/dhcp-*
        
        echo "바이너리 복구 완료"
    else
        echo "바이너리 백업 파일을 찾을 수 없음: $binary_file"
    fi
}

restore_logs() {
    echo "=== 로그 복구 (선택적) ==="
    
    local log_file="$BACKUP_DIR/logs/$RESTORE_DATE/dhcp-logs-$RESTORE_DATE.tar.gz"
    
    if [ -f "$log_file" ]; then
        read -p "로그도 복구하시겠습니까? (y/N): " -n 1 -r
        echo
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # 현재 로그 백업
            if [ -d "/var/log/dhcp-test" ]; then
                mv /var/log/dhcp-test "/var/log/dhcp-test-backup-$(date +%s)"
            fi
            
            # 로그 복구
            tar -xzf "$log_file" -C /var/log/
            chown -R dhcp-test:dhcp-test /var/log/dhcp-test
            
            echo "로그 복구 완료"
        fi
    else
        echo "로그 백업 파일을 찾을 수 없음: $log_file"
    fi
}

verify_restoration() {
    echo "=== 복구 검증 ==="
    
    # 파일 존재 확인
    if [ -f "/opt/dhcp-test/dhcp-server" ]; then
        echo "✅ DHCP 서버 바이너리 존재"
    else
        echo "❌ DHCP 서버 바이너리 없음"
    fi
    
    if [ -f "/opt/dhcp-test/dhcp-tester" ]; then
        echo "✅ DHCP 테스터 바이너리 존재"
    else
        echo "❌ DHCP 테스터 바이너리 없음"
    fi
    
    if [ -f "/etc/systemd/system/dhcp-test-server.service" ]; then
        echo "✅ systemd 서비스 파일 존재"
    else
        echo "❌ systemd 서비스 파일 없음"
    fi
    
    # 서비스 시작 테스트
    echo "서비스 시작 테스트 중..."
    systemctl start dhcp-test-server
    sleep 3
    
    if systemctl is-active dhcp-test-server > /dev/null; then
        echo "✅ 서비스 정상 시작됨"
    else
        echo "❌ 서비스 시작 실패"
        echo "로그 확인: journalctl -u dhcp-test-server"
    fi
}

# 메인 복구 실행
main_restore() {
    echo "DHCP 테스트 시스템 복구 시작: $RESTORE_DATE"
    
    restore_config
    restore_binaries
    restore_logs
    verify_restoration
    
    echo "복구 완료"
}

main_restore
```

---

이 운영 및 트러블슈팅 가이드를 통해 DHCP 성능 테스트 솔루션을 안정적으로 운영하고, 문제 발생 시 신속하게 해결할 수 있습니다.