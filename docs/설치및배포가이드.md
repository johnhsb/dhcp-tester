# DHCP 성능 테스트 솔루션 설치 및 배포 가이드

## 📋 목차
1. [시스템 요구사항](#1-시스템-요구사항)
2. [설치 방법](#2-설치-방법)
3. [배포 시나리오](#3-배포-시나리오)
4. [환경별 설정](#4-환경별-설정)
5. [자동화 스크립트](#5-자동화-스크립트)
6. [컨테이너 배포](#6-컨테이너-배포)
7. [모니터링 설정](#7-모니터링-설정)

## 1. 시스템 요구사항

### 1.1 하드웨어 요구사항

#### 최소 요구사항
- **CPU**: 2코어 이상
- **메모리**: 4GB RAM
- **디스크**: 1GB 여유 공간
- **네트워크**: 100Mbps 이상

#### 권장 요구사항
- **CPU**: 8코어 이상 (대량 테스트용)
- **메모리**: 16GB RAM (10,000+ 클라이언트)
- **디스크**: 10GB 여유 공간 (로그 저장용)
- **네트워크**: 1Gbps 이상

#### 대규모 환경 (100,000+ 클라이언트)
- **CPU**: 16코어 이상
- **메모리**: 32GB RAM 이상
- **디스크**: SSD 권장
- **네트워크**: 10Gbps 이상

### 1.2 소프트웨어 요구사항

#### 필수 소프트웨어
- **Go**: 1.16 이상 (컴파일용)
- **운영체제**: 
  - Linux (Ubuntu 18.04+, CentOS 7+, RHEL 7+)
  - macOS 10.14+
  - Windows 10+

#### 선택적 소프트웨어
- **Docker**: 컨테이너 배포용
- **Git**: 소스코드 관리용
- **Make**: 빌드 자동화용
- **Wireshark**: 패킷 분석용

### 1.3 네트워크 요구사항

#### 포트 사용
- **UDP 67**: DHCP 서버 포트
- **UDP 68**: DHCP 클라이언트 포트
- **TCP 6060**: 프로파일링 포트 (선택적)

#### 방화벽 설정
```bash
# Ubuntu/Debian
sudo ufw allow 67/udp
sudo ufw allow 68/udp

# CentOS/RHEL
sudo firewall-cmd --add-port=67/udp --permanent
sudo firewall-cmd --add-port=68/udp --permanent
sudo firewall-cmd --reload
```

## 2. 설치 방법

### 2.1 소스코드 컴파일

#### 기본 설치
```bash
# 1. Go 설치 확인
go version

# 2. 소스코드 다운로드
git clone <repository-url>
cd dhcp-performance-test-suite

# 3. 컴파일
go build -o dhcp-tester dhcp-tester.go
go build -o dhcp-server dhcp-server.go

# 4. 실행 권한 부여
chmod +x dhcp-tester dhcp-server

# 5. 설치 확인
./dhcp-tester -h
./dhcp-server -h
```

#### 최적화 빌드
```bash
# 성능 최적화 빌드
go build -ldflags="-s -w" -gcflags="-N -l" -o dhcp-tester-opt dhcp-tester.go
go build -ldflags="-s -w" -gcflags="-N -l" -o dhcp-server-opt dhcp-server.go

# 정적 링킹 빌드 (배포용)
CGO_ENABLED=0 GOOS=linux go build -a -ldflags="-s -w" -o dhcp-tester-static dhcp-tester.go
CGO_ENABLED=0 GOOS=linux go build -a -ldflags="-s -w" -o dhcp-server-static dhcp-server.go
```

### 2.2 크로스 플랫폼 빌드

```bash
# Linux 64비트
GOOS=linux GOARCH=amd64 go build -o dhcp-tester-linux-amd64 dhcp-tester.go
GOOS=linux GOARCH=amd64 go build -o dhcp-server-linux-amd64 dhcp-server.go

# Windows 64비트
GOOS=windows GOARCH=amd64 go build -o dhcp-tester-windows-amd64.exe dhcp-tester.go
GOOS=windows GOARCH=amd64 go build -o dhcp-server-windows-amd64.exe dhcp-server.go

# macOS 64비트
GOOS=darwin GOARCH=amd64 go build -o dhcp-tester-darwin-amd64 dhcp-tester.go
GOOS=darwin GOARCH=amd64 go build -o dhcp-server-darwin-amd64 dhcp-server.go

# ARM64 (Apple Silicon)
GOOS=darwin GOARCH=arm64 go build -o dhcp-tester-darwin-arm64 dhcp-tester.go
GOOS=darwin GOARCH=arm64 go build -o dhcp-server-darwin-arm64 dhcp-server.go
```

### 2.3 패키지 관리자 설치

#### Makefile 생성
```makefile
# Makefile
.PHONY: build install clean test

BINARY_CLIENT=dhcp-tester
BINARY_SERVER=dhcp-server
INSTALL_PATH=/usr/local/bin

build:
	go build -ldflags="-s -w" -o $(BINARY_CLIENT) dhcp-tester.go
	go build -ldflags="-s -w" -o $(BINARY_SERVER) dhcp-server.go

build-all:
	GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o $(BINARY_CLIENT)-linux-amd64 dhcp-tester.go
	GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o $(BINARY_SERVER)-linux-amd64 dhcp-server.go
	GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o $(BINARY_CLIENT)-windows-amd64.exe dhcp-tester.go
	GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o $(BINARY_SERVER)-windows-amd64.exe dhcp-server.go
	GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o $(BINARY_CLIENT)-darwin-amd64 dhcp-tester.go
	GOOS=darwin GOARCH=amd64 go build -ldflags="-s -w" -o $(BINARY_SERVER)-darwin-amd64 dhcp-server.go

install: build
	sudo cp $(BINARY_CLIENT) $(INSTALL_PATH)/
	sudo cp $(BINARY_SERVER) $(INSTALL_PATH)/
	sudo chmod +x $(INSTALL_PATH)/$(BINARY_CLIENT)
	sudo chmod +x $(INSTALL_PATH)/$(BINARY_SERVER)

uninstall:
	sudo rm -f $(INSTALL_PATH)/$(BINARY_CLIENT)
	sudo rm -f $(INSTALL_PATH)/$(BINARY_SERVER)

clean:
	rm -f $(BINARY_CLIENT)* $(BINARY_SERVER)*
	rm -f *.log *.pcap

test:
	go test -v ./...

benchmark:
	go test -bench=. -benchmem

.DEFAULT_GOAL := build
```

## 3. 배포 시나리오

### 3.1 단일 서버 배포

#### 로컬 테스트 환경
```bash
#!/bin/bash
# deploy-local.sh

echo "=== DHCP 테스트 환경 로컬 배포 ==="

# 1. 빌드
make build

# 2. 설정 파일 생성
cat > dhcp-server.conf << EOF
listen-ip=0.0.0.0
port=67
start-ip=192.168.100.10
end-ip=192.168.100.250
gateway=192.168.100.1
dns1=8.8.8.8
dns2=8.8.4.4
lease-time=24h
EOF

cat > dhcp-tester.conf << EOF
server=127.0.0.1
port=67
clients=1000
concurrency=100
timeout=30s
retry=true
max-discover-retries=3
max-request-retries=3
EOF

# 3. 실행 스크립트 생성
cat > run-server.sh << 'EOF'
#!/bin/bash
./dhcp-server -live -verbose \
  -start-ip 192.168.100.10 \
  -end-ip 192.168.100.250 \
  -gateway 192.168.100.1 \
  -dns1 8.8.8.8 \
  -dns2 8.8.4.4 \
  -lease-time 24h
EOF

cat > run-tester.sh << 'EOF'
#!/bin/bash
./dhcp-tester -server 127.0.0.1 \
  -clients 1000 -concurrency 100 \
  -retry -max-discover-retries 3 -max-request-retries 3 \
  -live -timeout 30s
EOF

chmod +x run-server.sh run-tester.sh

echo "배포 완료!"
echo "서버 시작: ./run-server.sh"
echo "테스터 실행: ./run-tester.sh"
```

### 3.2 분산 배포

#### 다중 서버 환경
```bash
#!/bin/bash
# deploy-distributed.sh

SERVERS=("server1.example.com" "server2.example.com" "server3.example.com")
BINARY_PATH="./dhcp-tester-linux-amd64"

echo "=== 분산 DHCP 테스트 배포 ==="

# 1. 바이너리 빌드
make build-all

# 2. 각 서버에 배포
for server in "${SERVERS[@]}"; do
    echo "서버 배포: $server"
    
    # 바이너리 복사
    scp $BINARY_PATH $server:/tmp/dhcp-tester
    
    # 원격 실행 스크립트 배포
    ssh $server << 'EOF'
        # 디렉토리 생성
        mkdir -p /opt/dhcp-test
        chmod 755 /opt/dhcp-test
        
        # 바이너리 이동
        sudo mv /tmp/dhcp-tester /opt/dhcp-test/
        sudo chmod +x /opt/dhcp-test/dhcp-tester
        
        # systemd 서비스 생성
        sudo cat > /etc/systemd/system/dhcp-tester.service << 'EOL'
[Unit]
Description=DHCP Performance Tester
After=network.target

[Service]
Type=simple
User=dhcp-test
ExecStart=/opt/dhcp-test/dhcp-tester -server 192.168.1.1 -clients 5000 -concurrency 200 -live
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOL

        # 서비스 활성화
        sudo systemctl daemon-reload
        sudo systemctl enable dhcp-tester
EOL

    echo "서버 $server 배포 완료"
done

echo "분산 배포 완료!"
```

### 3.3 클라우드 배포

#### AWS 배포 스크립트
```bash
#!/bin/bash
# deploy-aws.sh

# AWS CLI 설정 확인
if ! command -v aws &> /dev/null; then
    echo "AWS CLI가 설치되지 않았습니다."
    exit 1
fi

# 변수 설정
REGION="ap-northeast-2"
KEY_PAIR="dhcp-test-key"
SECURITY_GROUP="dhcp-test-sg"
INSTANCE_TYPE="c5.2xlarge"
AMI_ID="ami-0c9c942bd7bf113a2"  # Ubuntu 20.04 LTS

echo "=== AWS EC2 인스턴스 배포 ==="

# 1. 보안 그룹 생성
aws ec2 create-security-group \
    --group-name $SECURITY_GROUP \
    --description "DHCP Test Security Group" \
    --region $REGION

# DHCP 포트 허용
aws ec2 authorize-security-group-ingress \
    --group-name $SECURITY_GROUP \
    --protocol udp \
    --port 67 \
    --cidr 0.0.0.0/0 \
    --region $REGION

aws ec2 authorize-security-group-ingress \
    --group-name $SECURITY_GROUP \
    --protocol udp \
    --port 68 \
    --cidr 0.0.0.0/0 \
    --region $REGION

# SSH 포트 허용
aws ec2 authorize-security-group-ingress \
    --group-name $SECURITY_GROUP \
    --protocol tcp \
    --port 22 \
    --cidr 0.0.0.0/0 \
    --region $REGION

# 2. 사용자 데이터 스크립트 생성
cat > user-data.sh << 'EOF'
#!/bin/bash
apt-get update
apt-get install -y golang-go git make

# 사용자 생성
useradd -m -s /bin/bash dhcp-test
mkdir -p /home/dhcp-test/dhcp-suite
chown dhcp-test:dhcp-test /home/dhcp-test/dhcp-suite

# 소스코드 다운로드 및 빌드
cd /home/dhcp-test/dhcp-suite
git clone <repository-url> .
go build -o dhcp-tester dhcp-tester.go
go build -o dhcp-server dhcp-server.go
chown -R dhcp-test:dhcp-test /home/dhcp-test/

# 방화벽 설정
ufw allow 67/udp
ufw allow 68/udp
ufw --force enable
EOF

# 3. EC2 인스턴스 생성
INSTANCE_ID=$(aws ec2 run-instances \
    --image-id $AMI_ID \
    --count 1 \
    --instance-type $INSTANCE_TYPE \
    --key-name $KEY_PAIR \
    --security-groups $SECURITY_GROUP \
    --user-data file://user-data.sh \
    --region $REGION \
    --query 'Instances[0].InstanceId' \
    --output text)

echo "EC2 인스턴스 생성됨: $INSTANCE_ID"

# 4. 인스턴스 상태 확인
echo "인스턴스 시작 대기 중..."
aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region $REGION

# 5. 퍼블릭 IP 조회
PUBLIC_IP=$(aws ec2 describe-instances \
    --instance-ids $INSTANCE_ID \
    --region $REGION \
    --query 'Reservations[0].Instances[0].PublicIpAddress' \
    --output text)

echo "=== 배포 완료 ==="
echo "인스턴스 ID: $INSTANCE_ID"
echo "퍼블릭 IP: $PUBLIC_IP"
echo "SSH 접속: ssh -i $KEY_PAIR.pem ubuntu@$PUBLIC_IP"

# 정리 스크립트 생성
cat > cleanup-aws.sh << EOF
#!/bin/bash
echo "AWS 리소스 정리 중..."
aws ec2 terminate-instances --instance-ids $INSTANCE_ID --region $REGION
aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID --region $REGION
aws ec2 delete-security-group --group-name $SECURITY_GROUP --region $REGION
echo "정리 완료"
EOF

chmod +x cleanup-aws.sh
```

## 4. 환경별 설정

### 4.1 개발 환경

#### 개발용 설정 파일
```yaml
# config/development.yaml
server:
  listen_ip: "127.0.0.1"
  port: 6700  # 표준 포트 충돌 방지
  ip_pool:
    start: "10.0.100.10"
    end: "10.0.100.50"
  lease_time: "1h"
  
client:
  server_ip: "127.0.0.1"
  server_port: 6700
  test_size: 100
  concurrency: 10
  timeout: "10s"
  
logging:
  level: "debug"
  verbose: true
  live_stats: true
```

#### 개발 환경 실행 스크립트
```bash
#!/bin/bash
# scripts/dev-run.sh

# 개발 환경 변수 설정
export DHCP_ENV="development"
export DHCP_LOG_LEVEL="debug"

# 서버 시작 (백그라운드)
./dhcp-server -port 6700 \
  -start-ip 10.0.100.10 \
  -end-ip 10.0.100.50 \
  -lease-time 1h \
  -verbose -live &

SERVER_PID=$!
echo "DHCP 서버 시작됨 (PID: $SERVER_PID)"

# 잠시 대기
sleep 3

# 테스터 실행
./dhcp-tester -server 127.0.0.1 -port 6700 \
  -clients 100 -concurrency 10 \
  -timeout 10s -verbose

# 서버 종료
kill $SERVER_PID
echo "테스트 완료"
```

### 4.2 스테이징 환경

#### 스테이징용 설정
```bash
#!/bin/bash
# scripts/staging-setup.sh

# 환경 변수
export DHCP_ENV="staging"
export DHCP_SERVER_IP="192.168.200.1"
export DHCP_POOL_START="192.168.200.100"
export DHCP_POOL_END="192.168.200.200"

# 로그 디렉토리 생성
mkdir -p /var/log/dhcp-test
chown dhcp-test:dhcp-test /var/log/dhcp-test

# systemd 서비스 파일 생성
cat > /etc/systemd/system/dhcp-test-server.service << EOF
[Unit]
Description=DHCP Test Server (Staging)
After=network.target

[Service]
Type=simple
User=dhcp-test
WorkingDirectory=/opt/dhcp-test
ExecStart=/opt/dhcp-test/dhcp-server \\
  -listen $DHCP_SERVER_IP \\
  -port 67 \\
  -start-ip $DHCP_POOL_START \\
  -end-ip $DHCP_POOL_END \\
  -lease-time 2h \\
  -max-concurrent 2000 \\
  -response-delay 10ms \\
  -verbose
ExecReload=/bin/kill -HUP \$MAINPID
KillMode=process
Restart=always
RestartSec=5
StandardOutput=append:/var/log/dhcp-test/server.log
StandardError=append:/var/log/dhcp-test/server-error.log

[Install]
WantedBy=multi-user.target
EOF

# 서비스 활성화
systemctl daemon-reload
systemctl enable dhcp-test-server
systemctl start dhcp-test-server

echo "스테이징 환경 설정 완료"
```

### 4.3 운영 환경

#### 운영용 설정
```bash
#!/bin/bash
# scripts/production-setup.sh

# 보안 설정
umask 027

# 전용 사용자 생성
if ! id "dhcp-prod" &>/dev/null; then
    useradd -r -s /bin/false -d /opt/dhcp-prod dhcp-prod
fi

# 디렉토리 구조 생성
mkdir -p /opt/dhcp-prod/{bin,config,logs,data}
mkdir -p /etc/dhcp-test

# 설정 파일 생성
cat > /etc/dhcp-test/production.conf << EOF
# DHCP Production Configuration
DHCP_LISTEN_IP=0.0.0.0
DHCP_PORT=67
DHCP_START_IP=172.16.1.100
DHCP_END_IP=172.16.10.250
DHCP_GATEWAY=172.16.1.1
DHCP_DNS1=172.16.1.10
DHCP_DNS2=8.8.8.8
DHCP_LEASE_TIME=24h
DHCP_MAX_CONCURRENT=5000
DHCP_RESPONSE_DELAY=0ms
DHCP_DROP_RATE=0.0
LOG_LEVEL=info
ENABLE_RELAY=true
MAX_HOPS=4
EOF

# systemd 서비스 파일 (운영용)
cat > /etc/systemd/system/dhcp-prod-server.service << EOF
[Unit]
Description=DHCP Production Server
After=network.target
Wants=network.target

[Service]
Type=simple
User=dhcp-prod
Group=dhcp-prod
WorkingDirectory=/opt/dhcp-prod
EnvironmentFile=/etc/dhcp-test/production.conf
ExecStart=/opt/dhcp-prod/bin/dhcp-server \\
  -listen \${DHCP_LISTEN_IP} \\
  -port \${DHCP_PORT} \\
  -start-ip \${DHCP_START_IP} \\
  -end-ip \${DHCP_END_IP} \\
  -gateway \${DHCP_GATEWAY} \\
  -dns1 \${DHCP_DNS1} \\
  -dns2 \${DHCP_DNS2} \\
  -lease-time \${DHCP_LEASE_TIME} \\
  -max-concurrent \${DHCP_MAX_CONCURRENT} \\
  -response-delay \${DHCP_RESPONSE_DELAY} \\
  -drop-rate \${DHCP_DROP_RATE} \\
  -relay=\${ENABLE_RELAY} \\
  -max-hops \${MAX_HOPS}

# 보안 설정
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/dhcp-prod/logs /opt/dhcp-prod/data
PrivateTmp=true
ProtectKernelTunables=true
ProtectControlGroups=true
RestrictSUIDSGID=true

# 리소스 제한
LimitNOFILE=65536
LimitNPROC=4096

# 재시작 정책
Restart=always
RestartSec=10
TimeoutStopSec=30

# 로깅
StandardOutput=append:/opt/dhcp-prod/logs/server.log
StandardError=append:/opt/dhcp-prod/logs/server-error.log
SyslogIdentifier=dhcp-prod-server

[Install]
WantedBy=multi-user.target
EOF

# 로그 로테이션 설정
cat > /etc/logrotate.d/dhcp-prod << EOF
/opt/dhcp-prod/logs/*.log {
    daily
    rotate 30
    compress
    delaycompress
    missingok
    notifempty
    copytruncate
    su dhcp-prod dhcp-prod
}
EOF

# 권한 설정
chown -R dhcp-prod:dhcp-prod /opt/dhcp-prod
chmod 750 /opt/dhcp-prod
chmod 640 /etc/dhcp-test/production.conf

echo "운영 환경 설정 완료"
```

## 5. 자동화 스크립트

### 5.1 CI/CD 파이프라인

#### GitHub Actions
```yaml
# .github/workflows/build-and-test.yml
name: Build and Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.19
    
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
    
    - name: Run tests
      run: |
        go test -v ./...
        go test -race -coverprofile=coverage.out ./...
    
    - name: Run benchmarks
      run: go test -bench=. -benchmem ./...
    
    - name: Build binaries
      run: |
        make build-all
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: dhcp-test-binaries
        path: |
          dhcp-*-*
          !dhcp-*.go

  release:
    needs: test
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Go
      uses: actions/setup-go@v3
      with:
        go-version: 1.19
    
    - name: Build release binaries
      run: make build-all
    
    - name: Create Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: false
```

### 5.2 배포 자동화

#### Ansible 플레이북
```yaml
# ansible/deploy.yml
---
- hosts: dhcp_servers
  become: yes
  vars:
    dhcp_user: dhcp-test
    dhcp_home: /opt/dhcp-test
    dhcp_version: "{{ version | default('latest') }}"
  
  tasks:
    - name: Create dhcp user
      user:
        name: "{{ dhcp_user }}"
        system: yes
        shell: /bin/false
        home: "{{ dhcp_home }}"
        create_home: yes
    
    - name: Create directories
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ dhcp_user }}"
        group: "{{ dhcp_user }}"
        mode: '0755'
      loop:
        - "{{ dhcp_home }}/bin"
        - "{{ dhcp_home }}/config"
        - "{{ dhcp_home }}/logs"
    
    - name: Download binaries
      get_url:
        url: "https://github.com/example/dhcp-test/releases/download/{{ dhcp_version }}/dhcp-server-linux-amd64"
        dest: "{{ dhcp_home }}/bin/dhcp-server"
        owner: "{{ dhcp_user }}"
        group: "{{ dhcp_user }}"
        mode: '0755'
    
    - name: Download tester binary
      get_url:
        url: "https://github.com/example/dhcp-test/releases/download/{{ dhcp_version }}/dhcp-tester-linux-amd64"
        dest: "{{ dhcp_home }}/bin/dhcp-tester"
        owner: "{{ dhcp_user }}"
        group: "{{ dhcp_user }}"
        mode: '0755'
    
    - name: Install systemd service
      template:
        src: dhcp-server.service.j2
        dest: /etc/systemd/system/dhcp-server.service
      notify:
        - reload systemd
        - restart dhcp-server
    
    - name: Start and enable service
      systemd:
        name: dhcp-server
        state: started
        enabled: yes
        daemon_reload: yes
  
  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: yes
    
    - name: restart dhcp-server
      systemd:
        name: dhcp-server
        state: restarted
```

### 5.3 모니터링 스크립트

#### 헬스체크 스크립트
```bash
#!/bin/bash
# scripts/health-check.sh

# 설정
DHCP_SERVER="127.0.0.1"
DHCP_PORT="67"
LOG_FILE="/var/log/dhcp-test/health-check.log"
ALERT_THRESHOLD=90  # 실패율 90% 이상 시 알림

# 로그 함수
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 헬스체크 함수
health_check() {
    local test_name="$1"
    local clients="$2"
    local expected_success_rate="$3"
    
    log "헬스체크 시작: $test_name ($clients 클라이언트)"
    
    # 임시 결과 파일
    local result_file="/tmp/dhcp-health-check-$$.log"
    
    # 테스트 실행
    timeout 60s ./dhcp-tester \
        -server "$DHCP_SERVER" \
        -port "$DHCP_PORT" \
        -clients "$clients" \
        -concurrency 10 \
        -timeout 10s \
        -progress > "$result_file" 2>&1
    
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        # 성공률 추출
        local success_rate=$(grep "성공률:" "$result_file" | awk '{print $2}' | sed 's/%//')
        
        if [ -n "$success_rate" ]; then
            local success_rate_int=${success_rate%.*}  # 소수점 제거
            
            if [ "$success_rate_int" -ge "$expected_success_rate" ]; then
                log "✅ $test_name 성공: 성공률 ${success_rate}%"
                echo "PASS"
            else
                log "⚠️ $test_name 성공률 부족: ${success_rate}% (기대: ${expected_success_rate}%)"
                echo "WARN"
            fi
        else
            log "❌ $test_name 결과 파싱 실패"
            echo "FAIL"
        fi
    else
        log "❌ $test_name 실행 실패 (종료 코드: $exit_code)"
        echo "FAIL"
    fi
    
    rm -f "$result_file"
}

# 알림 발송 함수
send_alert() {
    local message="$1"
    
    # 이메일 알림 (선택적)
    if command -v mail &> /dev/null; then
        echo "$message" | mail -s "DHCP 헬스체크 알림" admin@example.com
    fi
    
    # 슬랙 알림 (선택적)
    if [ -n "$SLACK_WEBHOOK" ]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\"$message\"}" \
            "$SLACK_WEBHOOK"
    fi
    
    log "알림 발송: $message"
}

# 메인 헬스체크 로직
main() {
    log "=== DHCP 헬스체크 시작 ==="
    
    # 서버 연결 확인
    if ! nc -z -u "$DHCP_SERVER" "$DHCP_PORT" 2>/dev/null; then
        local alert_msg="❌ DHCP 서버 연결 실패: $DHCP_SERVER:$DHCP_PORT"
        log "$alert_msg"
        send_alert "$alert_msg"
        exit 1
    fi
    
    # 단계별 헬스체크
    local results=()
    
    results+=($(health_check "기본_테스트" 10 95))
    results+=($(health_check "중간_부하" 100 90))
    results+=($(health_check "높은_부하" 500 85))
    
    # 결과 분석
    local pass_count=0
    local warn_count=0
    local fail_count=0
    
    for result in "${results[@]}"; do
        case $result in
            "PASS") ((pass_count++)) ;;
            "WARN") ((warn_count++)) ;;
            "FAIL") ((fail_count++)) ;;
        esac
    done
    
    local total_tests=${#results[@]}
    local fail_rate=$((fail_count * 100 / total_tests))
    
    log "헬스체크 완료: PASS=$pass_count, WARN=$warn_count, FAIL=$fail_count"
    
    # 알림 조건 확인
    if [ $fail_rate -ge $ALERT_THRESHOLD ]; then
        local alert_msg="🚨 DHCP 서버 상태 위험: 실패율 ${fail_rate}% (${fail_count}/${total_tests})"
        send_alert "$alert_msg"
        exit 1
    elif [ $warn_count -gt 0 ]; then
        log "⚠️ 일부 테스트에서 성능 저하 감지됨"
    fi
    
    log "=== 헬스체크 완료 ==="
}

# 실행
main "$@"
```

## 6. 컨테이너 배포

### 6.1 Docker 이미지

#### Dockerfile
```dockerfile
# Dockerfile
FROM golang:1.19-alpine AS builder

# 빌드 의존성 설치
RUN apk add --no-cache git make

# 작업 디렉토리 설정
WORKDIR /app

# 소스코드 복사
COPY . .

# 빌드
RUN make build

# 런타임 이미지
FROM alpine:latest

# 런타임 의존성 설치
RUN apk add --no-cache ca-certificates tzdata \
    && adduser -D -s /bin/sh dhcp-test

# 바이너리 복사
COPY --from=builder /app/dhcp-tester /usr/local/bin/
COPY --from=builder /app/dhcp-server /usr/local/bin/

# 사용자 변경
USER dhcp-test

# 포트 노출
EXPOSE 67/udp 68/udp

# 기본 명령어
CMD ["dhcp-server"]
```

#### Docker Compose
```yaml
# docker-compose.yml
version: '3.8'

services:
  dhcp-server:
    build: .
    container_name: dhcp-server
    ports:
      - "67:67/udp"
      - "68:68/udp"
    environment:
      - DHCP_START_IP=192.168.100.10
      - DHCP_END_IP=192.168.100.250
      - DHCP_GATEWAY=192.168.100.1
    command: >
      dhcp-server 
      -start-ip ${DHCP_START_IP}
      -end-ip ${DHCP_END_IP}
      -gateway ${DHCP_GATEWAY}
      -live
    volumes:
      - ./logs:/var/log/dhcp-test
    restart: unless-stopped
    networks:
      - dhcp-net

  dhcp-tester:
    build: .
    container_name: dhcp-tester
    depends_on:
      - dhcp-server
    environment:
      - DHCP_SERVER=dhcp-server
      - DHCP_CLIENTS=1000
    command: >
      dhcp-tester
      -server ${DHCP_SERVER}
      -clients ${DHCP_CLIENTS}
      -concurrency 100
      -retry
      -live
    volumes:
      - ./results:/var/log/dhcp-test
    networks:
      - dhcp-net
    profiles:
      - test

networks:
  dhcp-net:
    driver: bridge
```

### 6.2 Kubernetes 배포

#### Deployment 매니페스트
```yaml
# k8s/dhcp-server-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dhcp-server
  labels:
    app: dhcp-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dhcp-server
  template:
    metadata:
      labels:
        app: dhcp-server
    spec:
      containers:
      - name: dhcp-server
        image: dhcp-test:latest
        command: ["dhcp-server"]
        args:
          - "-start-ip=10.42.0.10"
          - "-end-ip=10.42.0.250"
          - "-gateway=10.42.0.1"
          - "-live"
        ports:
        - containerPort: 67
          protocol: UDP
        - containerPort: 68
          protocol: UDP
        env:
        - name: DHCP_LOG_LEVEL
          value: "info"
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - "nc -z -u localhost 67"
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - "nc -z -u localhost 67"
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: dhcp-server-service
spec:
  selector:
    app: dhcp-server
  ports:
  - name: dhcp-server
    port: 67
    targetPort: 67
    protocol: UDP
  - name: dhcp-client
    port: 68
    targetPort: 68
    protocol: UDP
  type: LoadBalancer
```

#### Job 매니페스트 (테스터용)
```yaml
# k8s/dhcp-tester-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: dhcp-tester
spec:
  template:
    spec:
      containers:
      - name: dhcp-tester
        image: dhcp-test:latest
        command: ["dhcp-tester"]
        args:
          - "-server=dhcp-server-service"
          - "-clients=1000"
          - "-concurrency=100"
          - "-retry"
          - "-timeout=30s"
        env:
        - name: DHCP_LOG_LEVEL
          value: "info"
        resources:
          requests:
            memory: "1Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "4000m"
      restartPolicy: Never
  backoffLimit: 3
```

## 7. 모니터링 설정

### 7.1 메트릭 수집

#### Prometheus 메트릭 노출
```go
// metrics.go 예시
package main

import (
    "net/http"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
    dhcpRequestsTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "dhcp_requests_total",
            Help: "Total number of DHCP requests",
        },
        []string{"type", "status"},
    )
    
    dhcpResponseTime = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "dhcp_response_time_seconds",
            Help: "DHCP response time in seconds",
        },
        []string{"type"},
    )
)

func init() {
    prometheus.MustRegister(dhcpRequestsTotal)
    prometheus.MustRegister(dhcpResponseTime)
}

func startMetricsServer() {
    http.Handle("/metrics", promhttp.Handler())
    http.ListenAndServe(":8080", nil)
}
```

### 7.2 Grafana 대시보드

#### 대시보드 JSON
```json
{
  "dashboard": {
    "title": "DHCP Performance Test Dashboard",
    "panels": [
      {
        "title": "DHCP Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(dhcp_requests_total[5m])",
            "legendFormat": "{{type}} - {{status}}"
          }
        ]
      },
      {
        "title": "Response Time Distribution",
        "type": "heatmap",
        "targets": [
          {
            "expr": "dhcp_response_time_seconds_bucket",
            "legendFormat": "{{le}}"
          }
        ]
      }
    ]
  }
}
```

---

이 설치 및 배포 가이드를 통해 다양한 환경에서 DHCP 성능 테스트 솔루션을 효율적으로 배포하고 운영할 수 있습니다.