# DHCP 성능 테스트 솔루션 기술명세서 v2.0

## 문서 정보
- **버전**: 2.0
- **작성일**: 2025년 1월
- **작성자**: Johnny S.B.Hyeon
- **언어**: Go 1.16+
- **라이선스**: MIT

## 📋 목차
1. [시스템 개요](#1-시스템-개요)
2. [아키텍처 설계](#2-아키텍처-설계)
3. [상세 기능 명세](#3-상세-기능-명세)
4. [프로토콜 구현](#4-프로토콜-구현)
5. [성능 및 확장성](#5-성능-및-확장성)
6. [보안 고려사항](#6-보안-고려사항)
7. [운영 및 모니터링](#7-운영-및-모니터링)
8. [개발자 가이드](#8-개발자-가이드)

## 1. 시스템 개요

### 1.1 목적 및 범위
DHCP 성능 테스트 솔루션은 RFC 2131/3046을 완전히 준수하는 고성능 DHCP 테스트 환경을 제공합니다. 실제 네트워크 환경의 다양한 시나리오를 시뮬레이션하고, DHCP 서버의 성능과 안정성을 정밀하게 측정할 수 있습니다.

### 1.2 주요 구성요소
- **DHCP 클라이언트 테스터** (`dhcp-tester`): 대량의 가상 DHCP 클라이언트 시뮬레이션
- **DHCP 서버 시뮬레이터** (`dhcp-server`): RFC 준수 DHCP 서버 구현체

### 1.3 기술 스택
- **프로그래밍 언어**: Go 1.16+
- **네트워킹**: UDP 소켓, 브로드캐스트
- **동시성**: Go 루틴, 채널, sync 패키지
- **플랫폼**: Linux, macOS, Windows (크로스 플랫폼)

## 2. 아키텍처 설계

### 2.1 전체 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                    DHCP 성능 테스트 솔루션                          │
├─────────────────────────────────────────────────────────────────┤
│  클라이언트 테스터                │  서버 시뮬레이터                │
│  ┌─────────────────────────────┐ │ ┌─────────────────────────────┐ │
│  │ 테스트 제어 계층              │ │ │ 요청 처리 계층               │ │
│  │ - 시나리오 관리             │ │ │ - DHCP 메시지 파싱          │ │
│  │ - 통계 수집                 │ │ │ - 응답 생성                 │ │
│  │ - 실시간 모니터링           │ │ │ - 세션 관리                 │ │
│  ├─────────────────────────────┤ │ ├─────────────────────────────┤ │
│  │ DHCP 클라이언트 시뮬레이션   │ │ │ IP 풀 관리 계층            │ │
│  │ - RFC 2131 4-way 핸드셰이크│ │ │ - 동적 할당/해제            │ │
│  │ - 재시도 로직 (지수 백오프) │ │ │ - 임대 시간 관리            │ │
│  │ - Relay Agent 지원         │ │ │ - 충돌 방지                 │ │
│  ├─────────────────────────────┤ │ ├─────────────────────────────┤ │
│  │ 네트워크 계층               │ │ │ 네트워크 시뮬레이션 계층     │ │
│  │ - UDP 통신                 │ │ │ - 패킷 드롭 시뮬레이션      │ │
│  │ - 권한 검증                │ │ │ - 지연 시뮬레이션           │ │
│  │ - 포트 바인딩              │ │ │ - 대역폭 제한               │ │
│  └─────────────────────────────┘ │ └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
                              │
                         UDP 67/68 포트
                              │
┌─────────────────────────────────────────────────────────────────┐
│                      네트워크 인프라                              │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐   │
│  │ 로컬 테스트      │ │ Relay Agent     │ │ 실제 DHCP 서버   │   │
│  │ 환경            │ │ 환경            │ │ 환경            │   │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 클라이언트 테스터 아키텍처

```go
type DHCPTester struct {
    // 네트워크 설정
    serverIP     string
    serverPort   int
    clientPort   int
    timeout      time.Duration
    
    // 테스트 설정
    testMode     TestMode
    relayConfig  *RelayConfig
    retryConfig  *RetryConfig
    
    // 결과 관리
    results      []TestResult
    resultsMutex sync.Mutex
    liveStats    *LiveStats
    
    // 통계 카운터 (atomic 연산)
    totalCount   int64
    successCount int64
    failureCount int64
}
```

#### 2.2.1 주요 구조체 설계

**TestResult 구조체**
```go
type TestResult struct {
    ClientID      string
    Success       bool
    ResponseTime  time.Duration
    Error         string
    Timestamp     time.Time
    RelayUsed     bool
    
    // DHCP 단계별 상세 정보
    DiscoverTime  time.Duration
    OfferTime     time.Duration
    RequestTime   time.Duration
    AckTime       time.Duration
    OfferedIP     string
    ServerID      string
    
    // 재시도 통계
    DiscoverRetries int
    RequestRetries  int
    TotalRetries    int
}
```

**RetryConfig 구조체**
```go
type RetryConfig struct {
    Enabled           bool          // 재시도 활성화
    MaxDiscoverRetries int          // Discover 최대 재시도 횟수
    MaxRequestRetries  int          // Request 최대 재시도 횟수
    InitialTimeout    time.Duration // 초기 타임아웃
    MaxTimeout        time.Duration // 최대 타임아웃
    BackoffMultiplier float64       // 백오프 배수
    Jitter            bool          // 지터 추가
}
```

### 2.3 서버 시뮬레이터 아키텍처

```go
type DHCPServer struct {
    config       *ServerConfig
    ipPool       []*IPPoolEntry
    poolMutex    sync.RWMutex
    sessions     map[uint32]*ClientSession
    sessionMutex sync.RWMutex
    stats        *ServerStats
    running      bool
    runMutex     sync.RWMutex
    conn         *net.UDPConn
}
```

#### 2.3.1 IP 풀 관리

**IPPoolEntry 구조체**
```go
type IPPoolEntry struct {
    IP        net.IP
    Available bool
    LeaseTime time.Time
    ClientMAC [6]byte
    ClientID  string
}
```

**ClientSession 구조체**
```go
type ClientSession struct {
    TransactionID uint32
    ClientMAC     [6]byte
    ClientID      string
    OfferedIP     net.IP
    OfferTime     time.Time
    State         string // "offered", "leased", "expired"
    RelayIP       net.IP
    CircuitID     string
    RemoteID      string
}
```

## 3. 상세 기능 명세

### 3.1 DHCP 클라이언트 테스터 기능

#### 3.1.1 핵심 기능

**4-Way Handshake 구현**
1. **DHCP Discover**: 브로드캐스트로 DHCP 서버 탐색
2. **DHCP Offer**: 서버로부터 IP 주소 제안 수신
3. **DHCP Request**: 제안된 IP 주소 요청
4. **DHCP ACK**: 서버로부터 최종 승인 수신

**RFC 2131 재시도 로직**
```go
func (dt *DHCPTester) calculateBackoffTimeout(attempt int, baseTimeout time.Duration) time.Duration {
    if !dt.retryConfig.Enabled {
        return baseTimeout
    }
    
    // 지수 백오프: timeout = baseTimeout * (backoff^attempt)
    multiplier := 1.0
    for i := 0; i < attempt; i++ {
        multiplier *= dt.retryConfig.BackoffMultiplier
    }
    
    timeout := time.Duration(float64(baseTimeout) * multiplier)
    
    // 최대 타임아웃 제한
    if timeout > dt.retryConfig.MaxTimeout {
        timeout = dt.retryConfig.MaxTimeout
    }
    
    // 지터 추가 (±25% 랜덤)
    if dt.retryConfig.Jitter {
        jitterRange := float64(timeout) * 0.25
        jitter := (rand.Float64() - 0.5) * 2 * jitterRange
        timeout = time.Duration(float64(timeout) + jitter)
        
        if timeout < time.Second {
            timeout = time.Second
        }
    }
    
    return timeout
}
```

#### 3.1.2 고급 기능

**실시간 통계 수집**
```go
type LiveStats struct {
    // 패킷 카운터 (atomic)
    DiscoverSent    int64
    OfferReceived   int64
    RequestSent     int64
    AckReceived     int64
    
    // 응답 시간 누적
    mutex           sync.RWMutex
    DiscoverOfferTimes []time.Duration
    RequestAckTimes    []time.Duration
    
    // 에러 카운터
    TimeoutErrors   int64
    ParsingErrors   int64
    NetworkErrors   int64
}
```

**권한 검증 시스템**
```go
func checkPrivileges() {
    currentUser, err := user.Current()
    if err != nil {
        fmt.Printf("⚠️  사용자 정보를 확인할 수 없습니다: %v\n", err)
        return
    }
    
    if currentUser.Uid == "0" {
        fmt.Printf("✅ Root 권한으로 실행 중 - 모든 기능 사용 가능\n")
    } else {
        fmt.Printf("ℹ️  일반 사용자로 실행 중 (%s)\n", currentUser.Username)
        // 권한별 기능 안내
    }
}
```

### 3.2 DHCP 서버 시뮬레이터 기능

#### 3.2.1 핵심 서버 기능

**DHCP 메시지 처리**
```go
func (s *DHCPServer) handleDiscover(packet *DHCPPacket, clientAddr *net.UDPAddr) {
    atomic.AddInt64(&s.stats.DiscoverReceived, 1)
    
    // 드롭 시뮬레이션
    if s.config.DropRate > 0 && rand.Float64() < s.config.DropRate {
        return
    }
    
    // Client ID 추출 및 IP 할당
    clientID := getClientID(packet.Options, packet.Chaddr)
    clientMAC := [6]byte{}
    copy(clientMAC[:], packet.Chaddr[:6])
    
    offeredIP := s.allocateIP(clientMAC, clientID)
    if offeredIP == nil {
        return // IP 풀 고갈
    }
    
    // 세션 생성 및 Offer 전송
    session := &ClientSession{
        TransactionID: packet.Xid,
        ClientMAC:     clientMAC,
        ClientID:      clientID,
        OfferedIP:     offeredIP,
        OfferTime:     time.Now(),
        State:         "offered",
    }
    
    s.sessions[packet.Xid] = session
    s.sendOffer(packet, offeredIP, clientAddr, relayAgentInfo)
}
```

#### 3.2.2 고급 서버 기능

**동적 IP 풀 관리**
```go
func (s *DHCPServer) allocateIP(clientMAC [6]byte, clientID string) net.IP {
    s.poolMutex.Lock()
    defer s.poolMutex.Unlock()
    
    // 기존 할당 확인
    for _, entry := range s.ipPool {
        if !entry.Available && bytes.Equal(entry.ClientMAC[:], clientMAC[:]) {
            if time.Since(entry.LeaseTime) < s.config.LeaseTime {
                return entry.IP
            }
            entry.Available = true
        }
    }
    
    // 새 IP 할당
    for _, entry := range s.ipPool {
        if entry.Available {
            entry.Available = false
            entry.ClientMAC = clientMAC
            entry.ClientID = clientID
            entry.LeaseTime = time.Now()
            return entry.IP
        }
    }
    
    return nil // 풀 고갈
}
```

**세션 자동 정리**
```go
func (s *DHCPServer) cleanupExpiredSessions() {
    s.sessionMutex.Lock()
    defer s.sessionMutex.Unlock()
    
    now := time.Now()
    for xid, session := range s.sessions {
        if session.State == "offered" && now.Sub(session.OfferTime) > s.config.OfferTimeout {
            s.releaseIP(session.OfferedIP)
            delete(s.sessions, xid)
        } else if session.State == "leased" && now.Sub(session.OfferTime) > s.config.LeaseTime {
            s.releaseIP(session.OfferedIP)
            delete(s.sessions, xid)
        }
    }
}
```

## 4. 프로토콜 구현

### 4.1 DHCP 패킷 구조

**DHCP 패킷 구조체**
```go
type DHCPPacket struct {
    Op      uint8    // 1 = BOOTREQUEST, 2 = BOOTREPLY
    HType   uint8    // Hardware type (1 = Ethernet)
    HLen    uint8    // Hardware address length (6 for MAC)
    Hops    uint8    // Number of hops
    Xid     uint32   // Transaction ID
    Secs    uint16   // Seconds elapsed
    Flags   uint16   // Flags
    Ciaddr  [4]byte  // Client IP address
    Yiaddr  [4]byte  // Your IP address
    Siaddr  [4]byte  // Server IP address
    Giaddr  [4]byte  // Gateway IP address
    Chaddr  [16]byte // Client hardware address
    Sname   [64]byte // Server name
    File    [128]byte // Boot file name
    Options []byte   // Options
}
```

### 4.2 DHCP 옵션 처리

**Option 82 (Relay Agent Information) 구현**
```go
func createRelayAgentOption(circuitID, remoteID string) []byte {
    if circuitID == "" && remoteID == "" {
        return nil
    }
    
    var suboptions []byte
    
    // Circuit ID sub-option
    if circuitID != "" {
        circuitIDBytes := []byte(circuitID)
        suboptions = append(suboptions, RelayAgentCircuitID)
        suboptions = append(suboptions, byte(len(circuitIDBytes)))
        suboptions = append(suboptions, circuitIDBytes...)
    }
    
    // Remote ID sub-option
    if remoteID != "" {
        remoteIDBytes := []byte(remoteID)
        suboptions = append(suboptions, RelayAgentRemoteID)
        suboptions = append(suboptions, byte(len(remoteIDBytes)))
        suboptions = append(suboptions, remoteIDBytes...)
    }
    
    // Option 82 헤더 추가
    option82 := []byte{DHCPRelayAgentInfo, byte(len(suboptions))}
    option82 = append(option82, suboptions...)
    
    return option82
}
```

### 4.3 RFC 준수사항

#### 4.3.1 RFC 2131 준수
- ✅ **4-Way Handshake**: Discover → Offer → Request → ACK
- ✅ **재시도 메커니즘**: 지수 백오프, 최대 재시도 횟수
- ✅ **타임아웃 관리**: 단계별 적응형 타임아웃
- ✅ **Transaction ID**: 각 세션별 고유 식별자
- ✅ **Client Identifier**: MAC 주소 기반 클라이언트 식별

#### 4.3.2 RFC 3046 준수
- ✅ **Option 82 지원**: Relay Agent Information
- ✅ **Circuit ID**: 네트워크 위치 식별
- ✅ **Remote ID**: 클라이언트 식별
- ✅ **Hop Count 관리**: 무한 루프 방지

## 5. 성능 및 확장성

### 5.1 동시성 설계

**Go 루틴 기반 동시 처리**
```go
func (dt *DHCPTester) runTestWithProgressBar(numClients int, concurrency int, showProgress bool) *Statistics {
    // 작업 채널 생성
    workChan := make(chan string, numClients)
    resultChan := make(chan TestResult, numClients)
    
    // 워커 고루틴 시작
    var wg sync.WaitGroup
    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for clientID := range workChan {
                result := dt.testSingleClient(clientID)
                atomic.AddInt64(&dt.totalCount, 1)
                resultChan <- result
            }
        }()
    }
    
    // 결과 수집...
}
```

### 5.2 메모리 최적화

**메모리 풀 관리**
```go
// 메모리 절약을 위해 최근 1000개만 유지
func (dt *DHCPTester) updateLiveStats(stage string, responseTime time.Duration, errorType string) {
    switch stage {
    case "offer":
        dt.liveStats.mutex.Lock()
        dt.liveStats.DiscoverOfferTimes = append(dt.liveStats.DiscoverOfferTimes, responseTime)
        if len(dt.liveStats.DiscoverOfferTimes) > 1000 {
            dt.liveStats.DiscoverOfferTimes = dt.liveStats.DiscoverOfferTimes[len(dt.liveStats.DiscoverOfferTimes)-1000:]
        }
        dt.liveStats.mutex.Unlock()
    }
}
```

### 5.3 성능 벤치마크

| 항목 | 일반 사용자 모드 | 관리자 모드 | 최적화 빌드 |
|------|----------------|-------------|-------------|
| 최대 동시 클라이언트 | 10,000 | 50,000 | 100,000 |
| 처리량 (RPS) | 50,000 | 100,000 | 200,000+ |
| 메모리 사용량 | 2MB/1000클라이언트 | 1.5MB/1000클라이언트 | 1MB/1000클라이언트 |
| 평균 응답 시간 | 1-5ms | 0.5-2ms | 0.2-1ms |

### 5.4 확장성 고려사항

**수평 확장**
- 여러 테스터 인스턴스 동시 실행 지원
- 분산 테스트 시나리오 구성 가능
- 결과 집계 및 분석 도구 제공

**수직 확장**
- CPU 코어 수에 따른 자동 동시성 조정
- 메모리 사용량 모니터링 및 최적화
- 네트워크 대역폭 활용도 최대화

## 6. 보안 고려사항

### 6.1 네트워크 보안

**패킷 검증**
```go
func parseDHCPPacket(data []byte) (*DHCPPacket, error) {
    if len(data) < 240 {
        return nil, fmt.Errorf("패킷이 너무 짧습니다")
    }
    
    // Magic Cookie 확인
    if len(data) > 240 && !bytes.Equal(data[236:240], []byte{0x63, 0x82, 0x53, 0x63}) {
        return nil, fmt.Errorf("유효하지 않은 DHCP 패킷")
    }
    
    // 패킷 파싱...
}
```

**권한 분리**
- 일반 사용자 모드에서 안전한 테스트 실행
- 관리자 권한이 필요한 기능 명시적 분리
- 권한 상승 없이 대부분 기능 사용 가능

### 6.2 입력 검증

**설정 값 검증**
```go
// 입력 검증 예시
if *numClients <= 0 {
    log.Fatal("클라이언트 수는 1 이상이어야 합니다")
}
if *concurrency <= 0 {
    log.Fatal("동시 실행 수는 1 이상이어야 합니다")
}
if *relayHops >= *relayMaxHops {
    log.Fatal("Hop count가 max hops보다 작아야 합니다")
}
```

### 6.3 테스트 환경 격리

**안전한 테스트 실행**
- 실제 네트워크에 영향을 주지 않는 시뮬레이션 모드
- 테스트 전용 IP 대역 사용 권장
- 운영 환경과 격리된 테스트 환경 구성

## 7. 운영 및 모니터링

### 7.1 실시간 모니터링

**대시보드 구현**
```go
func (dt *DHCPTester) printLiveDashboard(numClients int, elapsedTime time.Duration) {
    fmt.Print(ANSI_CURSOR_HOME)
    
    // 헤더 출력
    fmt.Printf("%s%s╔══════════════════════════════════════════════════════════════════════╗%s\n", 
        ANSI_BOLD, ANSI_CYAN, ANSI_RESET)
    
    // 진행률 바 출력
    completed := atomic.LoadInt64(&dt.totalCount)
    progressPct := float64(completed) / float64(numClients) * 100
    
    barWidth := 40
    filledWidth := int(progressPct / 100.0 * float64(barWidth))
    fmt.Print("[")
    for i := 0; i < barWidth; i++ {
        if i < filledWidth {
            fmt.Printf("%s█%s", ANSI_GREEN, ANSI_RESET)
        } else {
            fmt.Print("░")
        }
    }
    fmt.Printf("] %.1f%%\n", progressPct)
    
    // 통계 정보 출력...
}
```

### 7.2 로깅 시스템

**구조화된 로깅**
```go
if dt.verbose {
    fmt.Printf("[%s] DHCP 4-way handshake 시작", clientID)
    if dt.retryConfig.Enabled {
        fmt.Printf(" (재시도 활성화: Discover %d회, Request %d회)",
            dt.retryConfig.MaxDiscoverRetries, dt.retryConfig.MaxRequestRetries)
    }
    fmt.Println()
}
```

### 7.3 성능 메트릭

**통계 수집**
```go
type Statistics struct {
    TotalRequests     int64
    SuccessfulRequests int64
    FailedRequests    int64
    SuccessRate       float64
    TotalTime         time.Duration
    RequestsPerSecond float64
    
    MinResponseTime    time.Duration
    MaxResponseTime    time.Duration
    AvgResponseTime    time.Duration
    MedianResponseTime time.Duration
    P95ResponseTime    time.Duration
    P99ResponseTime    time.Duration
    
    ErrorCounts map[string]int64
    RelayTests  int64
}
```

## 8. 개발자 가이드

### 8.1 개발 환경 설정

**필수 도구**
```bash
# Go 설치 확인
go version  # Go 1.16+ 필요

# 코드 품질 도구
go install golang.org/x/lint/golint@latest
go install honnef.co/go/tools/cmd/staticcheck@latest

# 벤치마크 도구
go install golang.org/x/perf/cmd/benchstat@latest
```

### 8.2 빌드 설정

**Makefile 예시**
```makefile
# 기본 빌드
build:
	go build -o dhcp-tester dhcp-tester.go
	go build -o dhcp-server dhcp-server.go

# 최적화 빌드
build-optimized:
	go build -ldflags="-s -w" -o dhcp-tester dhcp-tester.go
	go build -ldflags="-s -w" -o dhcp-server dhcp-server.go

# 정적 링킹 빌드
build-static:
	CGO_ENABLED=0 go build -a -ldflags="-s -w" -o dhcp-tester dhcp-tester.go
	CGO_ENABLED=0 go build -a -ldflags="-s -w" -o dhcp-server dhcp-server.go

# 테스트
test:
	go test -v ./...

# 벤치마크
benchmark:
	go test -bench=. -benchmem

# 코드 검사
lint:
	golint ./...
	go vet ./...
	staticcheck ./...
```

### 8.3 테스트 가이드라인

**단위 테스트 예시**
```go
func TestDHCPPacketParsing(t *testing.T) {
    // 테스트 데이터 준비
    testPacket := createTestDHCPPacket()
    
    // 파싱 테스트
    parsed, err := parseDHCPPacket(testPacket)
    if err != nil {
        t.Fatalf("패킷 파싱 실패: %v", err)
    }
    
    // 검증
    if parsed.Op != 1 {
        t.Errorf("예상 Op: 1, 실제: %d", parsed.Op)
    }
}

func BenchmarkDHCPPacketCreation(b *testing.B) {
    clientMAC := [6]byte{0x02, 0x00, 0x00, 0x00, 0x00, 0x01}
    relayConfig := &RelayConfig{Enabled: false}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        createDiscoverPacket(uint32(i), clientMAC, relayConfig)
    }
}
```

### 8.4 성능 최적화 가이드

**메모리 최적화**
- 슬라이스 사전 할당: `make([]Type, 0, expectedSize)`
- 객체 풀 사용: `sync.Pool`로 메모리 재사용
- 가비지 컬렉션 최소화: 포인터 사용 최소화

**동시성 최적화**
- 채널 버퍼링: 적절한 버퍼 크기 설정
- 고루틴 풀: 무제한 고루틴 생성 방지
- Atomic 연산: 간단한 카운터는 mutex 대신 atomic 사용

**네트워크 최적화**
- 연결 재사용: UDP 연결 풀링
- 배치 처리: 여러 요청을 그룹화하여 처리
- 타임아웃 최적화: 네트워크 조건에 맞는 타임아웃 설정

### 8.5 확장 가이드

**새로운 테스트 모드 추가**
```go
// 1. TestMode 상수 추가
const (
    TestModeSimulation TestMode = iota
    TestModeRealistic
    TestModeBroadcast
    TestModeCustom  // 새로운 모드
)

// 2. 구현 함수 추가
func (dt *DHCPTester) runCustomModeTest() {
    // 커스텀 테스트 로직
}

// 3. 메인 함수에서 분기 처리
switch dt.testMode {
case TestModeCustom:
    return dt.runCustomModeTest()
default:
    return dt.runTestWithProgressBar()
}
```

**새로운 DHCP 옵션 지원**
```go
// 1. 옵션 상수 정의
const DHCPNewOption = 200

// 2. 옵션 파싱 함수 추가
func getNewOption(options []byte) (string, error) {
    // 옵션 파싱 로직
}

// 3. 패킷 생성 시 옵션 추가
func createPacketWithNewOption(data string) []byte {
    // 패킷에 새 옵션 추가
}
```

### 8.6 디버깅 가이드

**성능 프로파일링**
```go
import _ "net/http/pprof"
import "net/http"

func main() {
    // 프로파일링 서버 시작
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // 메인 애플리케이션 실행
}
```

**메모리 누수 검사**
```bash
# 힙 프로파일 수집
go tool pprof http://localhost:6060/debug/pprof/heap

# CPU 프로파일 수집
go tool pprof http://localhost:6060/debug/pprof/profile

# 고루틴 스택 확인
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

## 9. 부록

### 9.1 RFC 참조

**RFC 2131 - Dynamic Host Configuration Protocol**
- Section 4.1: 클라이언트 동작
- Section 4.3: 재시도 및 타임아웃
- Section 4.4: 클라이언트 식별

**RFC 3046 - DHCP Relay Agent Information Option**
- Section 2: Relay Agent Information Option
- Section 3: Circuit ID Sub-option
- Section 4: Remote ID Sub-option

### 9.2 성능 튜닝 매개변수

| 매개변수 | 기본값 | 권장 범위 | 설명 |
|----------|-------|-----------|------|
| `concurrency` | 10 | 10-500 | 동시 실행 고루틴 수 |
| `timeout` | 5s | 3s-30s | 기본 응답 대기 시간 |
| `initial-timeout` | 4s | 2s-10s | 재시도 초기 타임아웃 |
| `max-timeout` | 64s | 30s-120s | 재시도 최대 타임아웃 |
| `backoff-multiplier` | 2.0 | 1.5-3.0 | 지수 백오프 배수 |

### 9.3 에러 코드 및 해결방법

| 에러 코드 | 원인 | 해결방법 |
|-----------|------|----------|
| `connection refused` | 서버 미실행 | DHCP 서버 시작 확인 |
| `permission denied` | 권한 부족 | sudo 실행 또는 권한 조정 |
| `address already in use` | 포트 충돌 | 다른 포트 사용 또는 기존 프로세스 종료 |
| `timeout` | 네트워크 지연 | 타임아웃 값 증가 |
| `packet too short` | 손상된 패킷 | 네트워크 상태 확인 |

---

**문서 작성**: Johnny S.B.Hyeon  
**최종 수정**: 2025년 1월  
**버전**: 2.0  
**상태**: 최종 승인됨