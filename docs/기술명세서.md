# DHCP ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì†”ë£¨ì…˜ ê¸°ìˆ ëª…ì„¸ì„œ v2.0

## ë¬¸ì„œ ì •ë³´
- **ë²„ì „**: 2.0
- **ì‘ì„±ì¼**: 2025ë…„ 1ì›”
- **ì‘ì„±ì**: Johnny S.B.Hyeon
- **ì–¸ì–´**: Go 1.16+
- **ë¼ì´ì„ ìŠ¤**: MIT

## ğŸ“‹ ëª©ì°¨
1. [ì‹œìŠ¤í…œ ê°œìš”](#1-ì‹œìŠ¤í…œ-ê°œìš”)
2. [ì•„í‚¤í…ì²˜ ì„¤ê³„](#2-ì•„í‚¤í…ì²˜-ì„¤ê³„)
3. [ìƒì„¸ ê¸°ëŠ¥ ëª…ì„¸](#3-ìƒì„¸-ê¸°ëŠ¥-ëª…ì„¸)
4. [í”„ë¡œí† ì½œ êµ¬í˜„](#4-í”„ë¡œí† ì½œ-êµ¬í˜„)
5. [ì„±ëŠ¥ ë° í™•ì¥ì„±](#5-ì„±ëŠ¥-ë°-í™•ì¥ì„±)
6. [ë³´ì•ˆ ê³ ë ¤ì‚¬í•­](#6-ë³´ì•ˆ-ê³ ë ¤ì‚¬í•­)
7. [ìš´ì˜ ë° ëª¨ë‹ˆí„°ë§](#7-ìš´ì˜-ë°-ëª¨ë‹ˆí„°ë§)
8. [ê°œë°œì ê°€ì´ë“œ](#8-ê°œë°œì-ê°€ì´ë“œ)

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ëª©ì  ë° ë²”ìœ„
DHCP ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì†”ë£¨ì…˜ì€ RFC 2131/3046ì„ ì™„ì „íˆ ì¤€ìˆ˜í•˜ëŠ” ê³ ì„±ëŠ¥ DHCP í…ŒìŠ¤íŠ¸ í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤. ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ í™˜ê²½ì˜ ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•˜ê³ , DHCP ì„œë²„ì˜ ì„±ëŠ¥ê³¼ ì•ˆì •ì„±ì„ ì •ë°€í•˜ê²Œ ì¸¡ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 1.2 ì£¼ìš” êµ¬ì„±ìš”ì†Œ
- **DHCP í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤í„°** (`dhcp-tester`): ëŒ€ëŸ‰ì˜ ê°€ìƒ DHCP í´ë¼ì´ì–¸íŠ¸ ì‹œë®¬ë ˆì´ì…˜
- **DHCP ì„œë²„ ì‹œë®¬ë ˆì´í„°** (`dhcp-server`): RFC ì¤€ìˆ˜ DHCP ì„œë²„ êµ¬í˜„ì²´

### 1.3 ê¸°ìˆ  ìŠ¤íƒ
- **í”„ë¡œê·¸ë˜ë° ì–¸ì–´**: Go 1.16+
- **ë„¤íŠ¸ì›Œí‚¹**: UDP ì†Œì¼“, ë¸Œë¡œë“œìºìŠ¤íŠ¸
- **ë™ì‹œì„±**: Go ë£¨í‹´, ì±„ë„, sync íŒ¨í‚¤ì§€
- **í”Œë«í¼**: Linux, macOS, Windows (í¬ë¡œìŠ¤ í”Œë«í¼)

## 2. ì•„í‚¤í…ì²˜ ì„¤ê³„

### 2.1 ì „ì²´ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DHCP ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì†”ë£¨ì…˜                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤í„°                â”‚  ì„œë²„ ì‹œë®¬ë ˆì´í„°                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ í…ŒìŠ¤íŠ¸ ì œì–´ ê³„ì¸µ              â”‚ â”‚ â”‚ ìš”ì²­ ì²˜ë¦¬ ê³„ì¸µ               â”‚ â”‚
â”‚  â”‚ - ì‹œë‚˜ë¦¬ì˜¤ ê´€ë¦¬             â”‚ â”‚ â”‚ - DHCP ë©”ì‹œì§€ íŒŒì‹±          â”‚ â”‚
â”‚  â”‚ - í†µê³„ ìˆ˜ì§‘                 â”‚ â”‚ â”‚ - ì‘ë‹µ ìƒì„±                 â”‚ â”‚
â”‚  â”‚ - ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§           â”‚ â”‚ â”‚ - ì„¸ì…˜ ê´€ë¦¬                 â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ DHCP í´ë¼ì´ì–¸íŠ¸ ì‹œë®¬ë ˆì´ì…˜   â”‚ â”‚ â”‚ IP í’€ ê´€ë¦¬ ê³„ì¸µ            â”‚ â”‚
â”‚  â”‚ - RFC 2131 4-way í•¸ë“œì…°ì´í¬â”‚ â”‚ â”‚ - ë™ì  í• ë‹¹/í•´ì œ            â”‚ â”‚
â”‚  â”‚ - ì¬ì‹œë„ ë¡œì§ (ì§€ìˆ˜ ë°±ì˜¤í”„) â”‚ â”‚ â”‚ - ì„ëŒ€ ì‹œê°„ ê´€ë¦¬            â”‚ â”‚
â”‚  â”‚ - Relay Agent ì§€ì›         â”‚ â”‚ â”‚ - ì¶©ëŒ ë°©ì§€                 â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ ë„¤íŠ¸ì›Œí¬ ê³„ì¸µ               â”‚ â”‚ â”‚ ë„¤íŠ¸ì›Œí¬ ì‹œë®¬ë ˆì´ì…˜ ê³„ì¸µ     â”‚ â”‚
â”‚  â”‚ - UDP í†µì‹                  â”‚ â”‚ â”‚ - íŒ¨í‚· ë“œë¡­ ì‹œë®¬ë ˆì´ì…˜      â”‚ â”‚
â”‚  â”‚ - ê¶Œí•œ ê²€ì¦                â”‚ â”‚ â”‚ - ì§€ì—° ì‹œë®¬ë ˆì´ì…˜           â”‚ â”‚
â”‚  â”‚ - í¬íŠ¸ ë°”ì¸ë”©              â”‚ â”‚ â”‚ - ëŒ€ì—­í­ ì œí•œ               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                         UDP 67/68 í¬íŠ¸
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ë„¤íŠ¸ì›Œí¬ ì¸í”„ë¼                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ë¡œì»¬ í…ŒìŠ¤íŠ¸      â”‚ â”‚ Relay Agent     â”‚ â”‚ ì‹¤ì œ DHCP ì„œë²„   â”‚   â”‚
â”‚  â”‚ í™˜ê²½            â”‚ â”‚ í™˜ê²½            â”‚ â”‚ í™˜ê²½            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤í„° ì•„í‚¤í…ì²˜

```go
type DHCPTester struct {
    // ë„¤íŠ¸ì›Œí¬ ì„¤ì •
    serverIP     string
    serverPort   int
    clientPort   int
    timeout      time.Duration
    
    // í…ŒìŠ¤íŠ¸ ì„¤ì •
    testMode     TestMode
    relayConfig  *RelayConfig
    retryConfig  *RetryConfig
    
    // ê²°ê³¼ ê´€ë¦¬
    results      []TestResult
    resultsMutex sync.Mutex
    liveStats    *LiveStats
    
    // í†µê³„ ì¹´ìš´í„° (atomic ì—°ì‚°)
    totalCount   int64
    successCount int64
    failureCount int64
}
```

#### 2.2.1 ì£¼ìš” êµ¬ì¡°ì²´ ì„¤ê³„

**TestResult êµ¬ì¡°ì²´**
```go
type TestResult struct {
    ClientID      string
    Success       bool
    ResponseTime  time.Duration
    Error         string
    Timestamp     time.Time
    RelayUsed     bool
    
    // DHCP ë‹¨ê³„ë³„ ìƒì„¸ ì •ë³´
    DiscoverTime  time.Duration
    OfferTime     time.Duration
    RequestTime   time.Duration
    AckTime       time.Duration
    OfferedIP     string
    ServerID      string
    
    // ì¬ì‹œë„ í†µê³„
    DiscoverRetries int
    RequestRetries  int
    TotalRetries    int
}
```

**RetryConfig êµ¬ì¡°ì²´**
```go
type RetryConfig struct {
    Enabled           bool          // ì¬ì‹œë„ í™œì„±í™”
    MaxDiscoverRetries int          // Discover ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜
    MaxRequestRetries  int          // Request ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜
    InitialTimeout    time.Duration // ì´ˆê¸° íƒ€ì„ì•„ì›ƒ
    MaxTimeout        time.Duration // ìµœëŒ€ íƒ€ì„ì•„ì›ƒ
    BackoffMultiplier float64       // ë°±ì˜¤í”„ ë°°ìˆ˜
    Jitter            bool          // ì§€í„° ì¶”ê°€
}
```

### 2.3 ì„œë²„ ì‹œë®¬ë ˆì´í„° ì•„í‚¤í…ì²˜

```go
type DHCPServer struct {
    config       *ServerConfig
    ipPool       []*IPPoolEntry
    poolMutex    sync.RWMutex
    sessions     map[uint32]*ClientSession
    sessionMutex sync.RWMutex
    stats        *ServerStats
    running      bool
    runMutex     sync.RWMutex
    conn         *net.UDPConn
}
```

#### 2.3.1 IP í’€ ê´€ë¦¬

**IPPoolEntry êµ¬ì¡°ì²´**
```go
type IPPoolEntry struct {
    IP        net.IP
    Available bool
    LeaseTime time.Time
    ClientMAC [6]byte
    ClientID  string
}
```

**ClientSession êµ¬ì¡°ì²´**
```go
type ClientSession struct {
    TransactionID uint32
    ClientMAC     [6]byte
    ClientID      string
    OfferedIP     net.IP
    OfferTime     time.Time
    State         string // "offered", "leased", "expired"
    RelayIP       net.IP
    CircuitID     string
    RemoteID      string
}
```

## 3. ìƒì„¸ ê¸°ëŠ¥ ëª…ì„¸

### 3.1 DHCP í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤í„° ê¸°ëŠ¥

#### 3.1.1 í•µì‹¬ ê¸°ëŠ¥

**4-Way Handshake êµ¬í˜„**
1. **DHCP Discover**: ë¸Œë¡œë“œìºìŠ¤íŠ¸ë¡œ DHCP ì„œë²„ íƒìƒ‰
2. **DHCP Offer**: ì„œë²„ë¡œë¶€í„° IP ì£¼ì†Œ ì œì•ˆ ìˆ˜ì‹ 
3. **DHCP Request**: ì œì•ˆëœ IP ì£¼ì†Œ ìš”ì²­
4. **DHCP ACK**: ì„œë²„ë¡œë¶€í„° ìµœì¢… ìŠ¹ì¸ ìˆ˜ì‹ 

**RFC 2131 ì¬ì‹œë„ ë¡œì§**
```go
func (dt *DHCPTester) calculateBackoffTimeout(attempt int, baseTimeout time.Duration) time.Duration {
    if !dt.retryConfig.Enabled {
        return baseTimeout
    }
    
    // ì§€ìˆ˜ ë°±ì˜¤í”„: timeout = baseTimeout * (backoff^attempt)
    multiplier := 1.0
    for i := 0; i < attempt; i++ {
        multiplier *= dt.retryConfig.BackoffMultiplier
    }
    
    timeout := time.Duration(float64(baseTimeout) * multiplier)
    
    // ìµœëŒ€ íƒ€ì„ì•„ì›ƒ ì œí•œ
    if timeout > dt.retryConfig.MaxTimeout {
        timeout = dt.retryConfig.MaxTimeout
    }
    
    // ì§€í„° ì¶”ê°€ (Â±25% ëœë¤)
    if dt.retryConfig.Jitter {
        jitterRange := float64(timeout) * 0.25
        jitter := (rand.Float64() - 0.5) * 2 * jitterRange
        timeout = time.Duration(float64(timeout) + jitter)
        
        if timeout < time.Second {
            timeout = time.Second
        }
    }
    
    return timeout
}
```

#### 3.1.2 ê³ ê¸‰ ê¸°ëŠ¥

**ì‹¤ì‹œê°„ í†µê³„ ìˆ˜ì§‘**
```go
type LiveStats struct {
    // íŒ¨í‚· ì¹´ìš´í„° (atomic)
    DiscoverSent    int64
    OfferReceived   int64
    RequestSent     int64
    AckReceived     int64
    
    // ì‘ë‹µ ì‹œê°„ ëˆ„ì 
    mutex           sync.RWMutex
    DiscoverOfferTimes []time.Duration
    RequestAckTimes    []time.Duration
    
    // ì—ëŸ¬ ì¹´ìš´í„°
    TimeoutErrors   int64
    ParsingErrors   int64
    NetworkErrors   int64
}
```

**ê¶Œí•œ ê²€ì¦ ì‹œìŠ¤í…œ**
```go
func checkPrivileges() {
    currentUser, err := user.Current()
    if err != nil {
        fmt.Printf("âš ï¸  ì‚¬ìš©ì ì •ë³´ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: %v\n", err)
        return
    }
    
    if currentUser.Uid == "0" {
        fmt.Printf("âœ… Root ê¶Œí•œìœ¼ë¡œ ì‹¤í–‰ ì¤‘ - ëª¨ë“  ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥\n")
    } else {
        fmt.Printf("â„¹ï¸  ì¼ë°˜ ì‚¬ìš©ìë¡œ ì‹¤í–‰ ì¤‘ (%s)\n", currentUser.Username)
        // ê¶Œí•œë³„ ê¸°ëŠ¥ ì•ˆë‚´
    }
}
```

### 3.2 DHCP ì„œë²„ ì‹œë®¬ë ˆì´í„° ê¸°ëŠ¥

#### 3.2.1 í•µì‹¬ ì„œë²„ ê¸°ëŠ¥

**DHCP ë©”ì‹œì§€ ì²˜ë¦¬**
```go
func (s *DHCPServer) handleDiscover(packet *DHCPPacket, clientAddr *net.UDPAddr) {
    atomic.AddInt64(&s.stats.DiscoverReceived, 1)
    
    // ë“œë¡­ ì‹œë®¬ë ˆì´ì…˜
    if s.config.DropRate > 0 && rand.Float64() < s.config.DropRate {
        return
    }
    
    // Client ID ì¶”ì¶œ ë° IP í• ë‹¹
    clientID := getClientID(packet.Options, packet.Chaddr)
    clientMAC := [6]byte{}
    copy(clientMAC[:], packet.Chaddr[:6])
    
    offeredIP := s.allocateIP(clientMAC, clientID)
    if offeredIP == nil {
        return // IP í’€ ê³ ê°ˆ
    }
    
    // ì„¸ì…˜ ìƒì„± ë° Offer ì „ì†¡
    session := &ClientSession{
        TransactionID: packet.Xid,
        ClientMAC:     clientMAC,
        ClientID:      clientID,
        OfferedIP:     offeredIP,
        OfferTime:     time.Now(),
        State:         "offered",
    }
    
    s.sessions[packet.Xid] = session
    s.sendOffer(packet, offeredIP, clientAddr, relayAgentInfo)
}
```

#### 3.2.2 ê³ ê¸‰ ì„œë²„ ê¸°ëŠ¥

**ë™ì  IP í’€ ê´€ë¦¬**
```go
func (s *DHCPServer) allocateIP(clientMAC [6]byte, clientID string) net.IP {
    s.poolMutex.Lock()
    defer s.poolMutex.Unlock()
    
    // ê¸°ì¡´ í• ë‹¹ í™•ì¸
    for _, entry := range s.ipPool {
        if !entry.Available && bytes.Equal(entry.ClientMAC[:], clientMAC[:]) {
            if time.Since(entry.LeaseTime) < s.config.LeaseTime {
                return entry.IP
            }
            entry.Available = true
        }
    }
    
    // ìƒˆ IP í• ë‹¹
    for _, entry := range s.ipPool {
        if entry.Available {
            entry.Available = false
            entry.ClientMAC = clientMAC
            entry.ClientID = clientID
            entry.LeaseTime = time.Now()
            return entry.IP
        }
    }
    
    return nil // í’€ ê³ ê°ˆ
}
```

**ì„¸ì…˜ ìë™ ì •ë¦¬**
```go
func (s *DHCPServer) cleanupExpiredSessions() {
    s.sessionMutex.Lock()
    defer s.sessionMutex.Unlock()
    
    now := time.Now()
    for xid, session := range s.sessions {
        if session.State == "offered" && now.Sub(session.OfferTime) > s.config.OfferTimeout {
            s.releaseIP(session.OfferedIP)
            delete(s.sessions, xid)
        } else if session.State == "leased" && now.Sub(session.OfferTime) > s.config.LeaseTime {
            s.releaseIP(session.OfferedIP)
            delete(s.sessions, xid)
        }
    }
}
```

## 4. í”„ë¡œí† ì½œ êµ¬í˜„

### 4.1 DHCP íŒ¨í‚· êµ¬ì¡°

**DHCP íŒ¨í‚· êµ¬ì¡°ì²´**
```go
type DHCPPacket struct {
    Op      uint8    // 1 = BOOTREQUEST, 2 = BOOTREPLY
    HType   uint8    // Hardware type (1 = Ethernet)
    HLen    uint8    // Hardware address length (6 for MAC)
    Hops    uint8    // Number of hops
    Xid     uint32   // Transaction ID
    Secs    uint16   // Seconds elapsed
    Flags   uint16   // Flags
    Ciaddr  [4]byte  // Client IP address
    Yiaddr  [4]byte  // Your IP address
    Siaddr  [4]byte  // Server IP address
    Giaddr  [4]byte  // Gateway IP address
    Chaddr  [16]byte // Client hardware address
    Sname   [64]byte // Server name
    File    [128]byte // Boot file name
    Options []byte   // Options
}
```

### 4.2 DHCP ì˜µì…˜ ì²˜ë¦¬

**Option 82 (Relay Agent Information) êµ¬í˜„**
```go
func createRelayAgentOption(circuitID, remoteID string) []byte {
    if circuitID == "" && remoteID == "" {
        return nil
    }
    
    var suboptions []byte
    
    // Circuit ID sub-option
    if circuitID != "" {
        circuitIDBytes := []byte(circuitID)
        suboptions = append(suboptions, RelayAgentCircuitID)
        suboptions = append(suboptions, byte(len(circuitIDBytes)))
        suboptions = append(suboptions, circuitIDBytes...)
    }
    
    // Remote ID sub-option
    if remoteID != "" {
        remoteIDBytes := []byte(remoteID)
        suboptions = append(suboptions, RelayAgentRemoteID)
        suboptions = append(suboptions, byte(len(remoteIDBytes)))
        suboptions = append(suboptions, remoteIDBytes...)
    }
    
    // Option 82 í—¤ë” ì¶”ê°€
    option82 := []byte{DHCPRelayAgentInfo, byte(len(suboptions))}
    option82 = append(option82, suboptions...)
    
    return option82
}
```

### 4.3 RFC ì¤€ìˆ˜ì‚¬í•­

#### 4.3.1 RFC 2131 ì¤€ìˆ˜
- âœ… **4-Way Handshake**: Discover â†’ Offer â†’ Request â†’ ACK
- âœ… **ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜**: ì§€ìˆ˜ ë°±ì˜¤í”„, ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜
- âœ… **íƒ€ì„ì•„ì›ƒ ê´€ë¦¬**: ë‹¨ê³„ë³„ ì ì‘í˜• íƒ€ì„ì•„ì›ƒ
- âœ… **Transaction ID**: ê° ì„¸ì…˜ë³„ ê³ ìœ  ì‹ë³„ì
- âœ… **Client Identifier**: MAC ì£¼ì†Œ ê¸°ë°˜ í´ë¼ì´ì–¸íŠ¸ ì‹ë³„

#### 4.3.2 RFC 3046 ì¤€ìˆ˜
- âœ… **Option 82 ì§€ì›**: Relay Agent Information
- âœ… **Circuit ID**: ë„¤íŠ¸ì›Œí¬ ìœ„ì¹˜ ì‹ë³„
- âœ… **Remote ID**: í´ë¼ì´ì–¸íŠ¸ ì‹ë³„
- âœ… **Hop Count ê´€ë¦¬**: ë¬´í•œ ë£¨í”„ ë°©ì§€

## 5. ì„±ëŠ¥ ë° í™•ì¥ì„±

### 5.1 ë™ì‹œì„± ì„¤ê³„

**Go ë£¨í‹´ ê¸°ë°˜ ë™ì‹œ ì²˜ë¦¬**
```go
func (dt *DHCPTester) runTestWithProgressBar(numClients int, concurrency int, showProgress bool) *Statistics {
    // ì‘ì—… ì±„ë„ ìƒì„±
    workChan := make(chan string, numClients)
    resultChan := make(chan TestResult, numClients)
    
    // ì›Œì»¤ ê³ ë£¨í‹´ ì‹œì‘
    var wg sync.WaitGroup
    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for clientID := range workChan {
                result := dt.testSingleClient(clientID)
                atomic.AddInt64(&dt.totalCount, 1)
                resultChan <- result
            }
        }()
    }
    
    // ê²°ê³¼ ìˆ˜ì§‘...
}
```

### 5.2 ë©”ëª¨ë¦¬ ìµœì í™”

**ë©”ëª¨ë¦¬ í’€ ê´€ë¦¬**
```go
// ë©”ëª¨ë¦¬ ì ˆì•½ì„ ìœ„í•´ ìµœê·¼ 1000ê°œë§Œ ìœ ì§€
func (dt *DHCPTester) updateLiveStats(stage string, responseTime time.Duration, errorType string) {
    switch stage {
    case "offer":
        dt.liveStats.mutex.Lock()
        dt.liveStats.DiscoverOfferTimes = append(dt.liveStats.DiscoverOfferTimes, responseTime)
        if len(dt.liveStats.DiscoverOfferTimes) > 1000 {
            dt.liveStats.DiscoverOfferTimes = dt.liveStats.DiscoverOfferTimes[len(dt.liveStats.DiscoverOfferTimes)-1000:]
        }
        dt.liveStats.mutex.Unlock()
    }
}
```

### 5.3 ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

| í•­ëª© | ì¼ë°˜ ì‚¬ìš©ì ëª¨ë“œ | ê´€ë¦¬ì ëª¨ë“œ | ìµœì í™” ë¹Œë“œ |
|------|----------------|-------------|-------------|
| ìµœëŒ€ ë™ì‹œ í´ë¼ì´ì–¸íŠ¸ | 10,000 | 50,000 | 100,000 |
| ì²˜ë¦¬ëŸ‰ (RPS) | 50,000 | 100,000 | 200,000+ |
| ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ | 2MB/1000í´ë¼ì´ì–¸íŠ¸ | 1.5MB/1000í´ë¼ì´ì–¸íŠ¸ | 1MB/1000í´ë¼ì´ì–¸íŠ¸ |
| í‰ê·  ì‘ë‹µ ì‹œê°„ | 1-5ms | 0.5-2ms | 0.2-1ms |

### 5.4 í™•ì¥ì„± ê³ ë ¤ì‚¬í•­

**ìˆ˜í‰ í™•ì¥**
- ì—¬ëŸ¬ í…ŒìŠ¤í„° ì¸ìŠ¤í„´ìŠ¤ ë™ì‹œ ì‹¤í–‰ ì§€ì›
- ë¶„ì‚° í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ êµ¬ì„± ê°€ëŠ¥
- ê²°ê³¼ ì§‘ê³„ ë° ë¶„ì„ ë„êµ¬ ì œê³µ

**ìˆ˜ì§ í™•ì¥**
- CPU ì½”ì–´ ìˆ˜ì— ë”°ë¥¸ ìë™ ë™ì‹œì„± ì¡°ì •
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§ ë° ìµœì í™”
- ë„¤íŠ¸ì›Œí¬ ëŒ€ì—­í­ í™œìš©ë„ ìµœëŒ€í™”

## 6. ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 6.1 ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ

**íŒ¨í‚· ê²€ì¦**
```go
func parseDHCPPacket(data []byte) (*DHCPPacket, error) {
    if len(data) < 240 {
        return nil, fmt.Errorf("íŒ¨í‚·ì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤")
    }
    
    // Magic Cookie í™•ì¸
    if len(data) > 240 && !bytes.Equal(data[236:240], []byte{0x63, 0x82, 0x53, 0x63}) {
        return nil, fmt.Errorf("ìœ íš¨í•˜ì§€ ì•Šì€ DHCP íŒ¨í‚·")
    }
    
    // íŒ¨í‚· íŒŒì‹±...
}
```

**ê¶Œí•œ ë¶„ë¦¬**
- ì¼ë°˜ ì‚¬ìš©ì ëª¨ë“œì—ì„œ ì•ˆì „í•œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
- ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•œ ê¸°ëŠ¥ ëª…ì‹œì  ë¶„ë¦¬
- ê¶Œí•œ ìƒìŠ¹ ì—†ì´ ëŒ€ë¶€ë¶„ ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥

### 6.2 ì…ë ¥ ê²€ì¦

**ì„¤ì • ê°’ ê²€ì¦**
```go
// ì…ë ¥ ê²€ì¦ ì˜ˆì‹œ
if *numClients <= 0 {
    log.Fatal("í´ë¼ì´ì–¸íŠ¸ ìˆ˜ëŠ” 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
}
if *concurrency <= 0 {
    log.Fatal("ë™ì‹œ ì‹¤í–‰ ìˆ˜ëŠ” 1 ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
}
if *relayHops >= *relayMaxHops {
    log.Fatal("Hop countê°€ max hopsë³´ë‹¤ ì‘ì•„ì•¼ í•©ë‹ˆë‹¤")
}
```

### 6.3 í…ŒìŠ¤íŠ¸ í™˜ê²½ ê²©ë¦¬

**ì•ˆì „í•œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰**
- ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ
- í…ŒìŠ¤íŠ¸ ì „ìš© IP ëŒ€ì—­ ì‚¬ìš© ê¶Œì¥
- ìš´ì˜ í™˜ê²½ê³¼ ê²©ë¦¬ëœ í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì„±

## 7. ìš´ì˜ ë° ëª¨ë‹ˆí„°ë§

### 7.1 ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

**ëŒ€ì‹œë³´ë“œ êµ¬í˜„**
```go
func (dt *DHCPTester) printLiveDashboard(numClients int, elapsedTime time.Duration) {
    fmt.Print(ANSI_CURSOR_HOME)
    
    // í—¤ë” ì¶œë ¥
    fmt.Printf("%s%sâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—%s\n", 
        ANSI_BOLD, ANSI_CYAN, ANSI_RESET)
    
    // ì§„í–‰ë¥  ë°” ì¶œë ¥
    completed := atomic.LoadInt64(&dt.totalCount)
    progressPct := float64(completed) / float64(numClients) * 100
    
    barWidth := 40
    filledWidth := int(progressPct / 100.0 * float64(barWidth))
    fmt.Print("[")
    for i := 0; i < barWidth; i++ {
        if i < filledWidth {
            fmt.Printf("%sâ–ˆ%s", ANSI_GREEN, ANSI_RESET)
        } else {
            fmt.Print("â–‘")
        }
    }
    fmt.Printf("] %.1f%%\n", progressPct)
    
    // í†µê³„ ì •ë³´ ì¶œë ¥...
}
```

### 7.2 ë¡œê¹… ì‹œìŠ¤í…œ

**êµ¬ì¡°í™”ëœ ë¡œê¹…**
```go
if dt.verbose {
    fmt.Printf("[%s] DHCP 4-way handshake ì‹œì‘", clientID)
    if dt.retryConfig.Enabled {
        fmt.Printf(" (ì¬ì‹œë„ í™œì„±í™”: Discover %díšŒ, Request %díšŒ)",
            dt.retryConfig.MaxDiscoverRetries, dt.retryConfig.MaxRequestRetries)
    }
    fmt.Println()
}
```

### 7.3 ì„±ëŠ¥ ë©”íŠ¸ë¦­

**í†µê³„ ìˆ˜ì§‘**
```go
type Statistics struct {
    TotalRequests     int64
    SuccessfulRequests int64
    FailedRequests    int64
    SuccessRate       float64
    TotalTime         time.Duration
    RequestsPerSecond float64
    
    MinResponseTime    time.Duration
    MaxResponseTime    time.Duration
    AvgResponseTime    time.Duration
    MedianResponseTime time.Duration
    P95ResponseTime    time.Duration
    P99ResponseTime    time.Duration
    
    ErrorCounts map[string]int64
    RelayTests  int64
}
```

## 8. ê°œë°œì ê°€ì´ë“œ

### 8.1 ê°œë°œ í™˜ê²½ ì„¤ì •

**í•„ìˆ˜ ë„êµ¬**
```bash
# Go ì„¤ì¹˜ í™•ì¸
go version  # Go 1.16+ í•„ìš”

# ì½”ë“œ í’ˆì§ˆ ë„êµ¬
go install golang.org/x/lint/golint@latest
go install honnef.co/go/tools/cmd/staticcheck@latest

# ë²¤ì¹˜ë§ˆí¬ ë„êµ¬
go install golang.org/x/perf/cmd/benchstat@latest
```

### 8.2 ë¹Œë“œ ì„¤ì •

**Makefile ì˜ˆì‹œ**
```makefile
# ê¸°ë³¸ ë¹Œë“œ
build:
	go build -o dhcp-tester dhcp-tester.go
	go build -o dhcp-server dhcp-server.go

# ìµœì í™” ë¹Œë“œ
build-optimized:
	go build -ldflags="-s -w" -o dhcp-tester dhcp-tester.go
	go build -ldflags="-s -w" -o dhcp-server dhcp-server.go

# ì •ì  ë§í‚¹ ë¹Œë“œ
build-static:
	CGO_ENABLED=0 go build -a -ldflags="-s -w" -o dhcp-tester dhcp-tester.go
	CGO_ENABLED=0 go build -a -ldflags="-s -w" -o dhcp-server dhcp-server.go

# í…ŒìŠ¤íŠ¸
test:
	go test -v ./...

# ë²¤ì¹˜ë§ˆí¬
benchmark:
	go test -bench=. -benchmem

# ì½”ë“œ ê²€ì‚¬
lint:
	golint ./...
	go vet ./...
	staticcheck ./...
```

### 8.3 í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸

**ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ**
```go
func TestDHCPPacketParsing(t *testing.T) {
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ì¤€ë¹„
    testPacket := createTestDHCPPacket()
    
    // íŒŒì‹± í…ŒìŠ¤íŠ¸
    parsed, err := parseDHCPPacket(testPacket)
    if err != nil {
        t.Fatalf("íŒ¨í‚· íŒŒì‹± ì‹¤íŒ¨: %v", err)
    }
    
    // ê²€ì¦
    if parsed.Op != 1 {
        t.Errorf("ì˜ˆìƒ Op: 1, ì‹¤ì œ: %d", parsed.Op)
    }
}

func BenchmarkDHCPPacketCreation(b *testing.B) {
    clientMAC := [6]byte{0x02, 0x00, 0x00, 0x00, 0x00, 0x01}
    relayConfig := &RelayConfig{Enabled: false}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        createDiscoverPacket(uint32(i), clientMAC, relayConfig)
    }
}
```

### 8.4 ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ

**ë©”ëª¨ë¦¬ ìµœì í™”**
- ìŠ¬ë¼ì´ìŠ¤ ì‚¬ì „ í• ë‹¹: `make([]Type, 0, expectedSize)`
- ê°ì²´ í’€ ì‚¬ìš©: `sync.Pool`ë¡œ ë©”ëª¨ë¦¬ ì¬ì‚¬ìš©
- ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ìµœì†Œí™”: í¬ì¸í„° ì‚¬ìš© ìµœì†Œí™”

**ë™ì‹œì„± ìµœì í™”**
- ì±„ë„ ë²„í¼ë§: ì ì ˆí•œ ë²„í¼ í¬ê¸° ì„¤ì •
- ê³ ë£¨í‹´ í’€: ë¬´ì œí•œ ê³ ë£¨í‹´ ìƒì„± ë°©ì§€
- Atomic ì—°ì‚°: ê°„ë‹¨í•œ ì¹´ìš´í„°ëŠ” mutex ëŒ€ì‹  atomic ì‚¬ìš©

**ë„¤íŠ¸ì›Œí¬ ìµœì í™”**
- ì—°ê²° ì¬ì‚¬ìš©: UDP ì—°ê²° í’€ë§
- ë°°ì¹˜ ì²˜ë¦¬: ì—¬ëŸ¬ ìš”ì²­ì„ ê·¸ë£¹í™”í•˜ì—¬ ì²˜ë¦¬
- íƒ€ì„ì•„ì›ƒ ìµœì í™”: ë„¤íŠ¸ì›Œí¬ ì¡°ê±´ì— ë§ëŠ” íƒ€ì„ì•„ì›ƒ ì„¤ì •

### 8.5 í™•ì¥ ê°€ì´ë“œ

**ìƒˆë¡œìš´ í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì¶”ê°€**
```go
// 1. TestMode ìƒìˆ˜ ì¶”ê°€
const (
    TestModeSimulation TestMode = iota
    TestModeRealistic
    TestModeBroadcast
    TestModeCustom  // ìƒˆë¡œìš´ ëª¨ë“œ
)

// 2. êµ¬í˜„ í•¨ìˆ˜ ì¶”ê°€
func (dt *DHCPTester) runCustomModeTest() {
    // ì»¤ìŠ¤í…€ í…ŒìŠ¤íŠ¸ ë¡œì§
}

// 3. ë©”ì¸ í•¨ìˆ˜ì—ì„œ ë¶„ê¸° ì²˜ë¦¬
switch dt.testMode {
case TestModeCustom:
    return dt.runCustomModeTest()
default:
    return dt.runTestWithProgressBar()
}
```

**ìƒˆë¡œìš´ DHCP ì˜µì…˜ ì§€ì›**
```go
// 1. ì˜µì…˜ ìƒìˆ˜ ì •ì˜
const DHCPNewOption = 200

// 2. ì˜µì…˜ íŒŒì‹± í•¨ìˆ˜ ì¶”ê°€
func getNewOption(options []byte) (string, error) {
    // ì˜µì…˜ íŒŒì‹± ë¡œì§
}

// 3. íŒ¨í‚· ìƒì„± ì‹œ ì˜µì…˜ ì¶”ê°€
func createPacketWithNewOption(data string) []byte {
    // íŒ¨í‚·ì— ìƒˆ ì˜µì…˜ ì¶”ê°€
}
```

### 8.6 ë””ë²„ê¹… ê°€ì´ë“œ

**ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§**
```go
import _ "net/http/pprof"
import "net/http"

func main() {
    // í”„ë¡œíŒŒì¼ë§ ì„œë²„ ì‹œì‘
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    
    // ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
}
```

**ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê²€ì‚¬**
```bash
# í™ í”„ë¡œíŒŒì¼ ìˆ˜ì§‘
go tool pprof http://localhost:6060/debug/pprof/heap

# CPU í”„ë¡œíŒŒì¼ ìˆ˜ì§‘
go tool pprof http://localhost:6060/debug/pprof/profile

# ê³ ë£¨í‹´ ìŠ¤íƒ í™•ì¸
go tool pprof http://localhost:6060/debug/pprof/goroutine
```

## 9. ë¶€ë¡

### 9.1 RFC ì°¸ì¡°

**RFC 2131 - Dynamic Host Configuration Protocol**
- Section 4.1: í´ë¼ì´ì–¸íŠ¸ ë™ì‘
- Section 4.3: ì¬ì‹œë„ ë° íƒ€ì„ì•„ì›ƒ
- Section 4.4: í´ë¼ì´ì–¸íŠ¸ ì‹ë³„

**RFC 3046 - DHCP Relay Agent Information Option**
- Section 2: Relay Agent Information Option
- Section 3: Circuit ID Sub-option
- Section 4: Remote ID Sub-option

### 9.2 ì„±ëŠ¥ íŠœë‹ ë§¤ê°œë³€ìˆ˜

| ë§¤ê°œë³€ìˆ˜ | ê¸°ë³¸ê°’ | ê¶Œì¥ ë²”ìœ„ | ì„¤ëª… |
|----------|-------|-----------|------|
| `concurrency` | 10 | 10-500 | ë™ì‹œ ì‹¤í–‰ ê³ ë£¨í‹´ ìˆ˜ |
| `timeout` | 5s | 3s-30s | ê¸°ë³¸ ì‘ë‹µ ëŒ€ê¸° ì‹œê°„ |
| `initial-timeout` | 4s | 2s-10s | ì¬ì‹œë„ ì´ˆê¸° íƒ€ì„ì•„ì›ƒ |
| `max-timeout` | 64s | 30s-120s | ì¬ì‹œë„ ìµœëŒ€ íƒ€ì„ì•„ì›ƒ |
| `backoff-multiplier` | 2.0 | 1.5-3.0 | ì§€ìˆ˜ ë°±ì˜¤í”„ ë°°ìˆ˜ |

### 9.3 ì—ëŸ¬ ì½”ë“œ ë° í•´ê²°ë°©ë²•

| ì—ëŸ¬ ì½”ë“œ | ì›ì¸ | í•´ê²°ë°©ë²• |
|-----------|------|----------|
| `connection refused` | ì„œë²„ ë¯¸ì‹¤í–‰ | DHCP ì„œë²„ ì‹œì‘ í™•ì¸ |
| `permission denied` | ê¶Œí•œ ë¶€ì¡± | sudo ì‹¤í–‰ ë˜ëŠ” ê¶Œí•œ ì¡°ì • |
| `address already in use` | í¬íŠ¸ ì¶©ëŒ | ë‹¤ë¥¸ í¬íŠ¸ ì‚¬ìš© ë˜ëŠ” ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ |
| `timeout` | ë„¤íŠ¸ì›Œí¬ ì§€ì—° | íƒ€ì„ì•„ì›ƒ ê°’ ì¦ê°€ |
| `packet too short` | ì†ìƒëœ íŒ¨í‚· | ë„¤íŠ¸ì›Œí¬ ìƒíƒœ í™•ì¸ |

---

**ë¬¸ì„œ ì‘ì„±**: Johnny S.B.Hyeon  
**ìµœì¢… ìˆ˜ì •**: 2025ë…„ 1ì›”  
**ë²„ì „**: 2.0  
**ìƒíƒœ**: ìµœì¢… ìŠ¹ì¸ë¨